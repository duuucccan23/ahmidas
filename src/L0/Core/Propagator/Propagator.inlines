namespace Core
{

  template< size_t L, size_t T >
  inline Propagator< L, T >::Propagator(bool alloc)
    : d_references(new size_t(1)),
      psize((size_t)(std::pow(4,nDirac)*std::pow(3,nColour))),
      colour_strides(new size_t[nColour]),
      dirac_strides(new size_t[nDirac])
  {
    if(alloc)
    {
      Field< std::complex< double >, L, T > *components = new Field< std::complex< double >, L, T > [size()];
      d_components = &components;
    }
    colour_strides[0] = 1;
    dirac_strides[0]  = 3;
    colour_strides[1] = 12;
    dirac_strides[1]  = 36;
    
//     colour_strides[0] = 1;
//     for (size_t idx=1; idx<numColour(); idx++)
//       colour_strides[idx] = size_t(3*(colour_strides[idx-1]));

//     dirac_strides[0] = (size_t)std::pow(3,numColour());
//     for (size_t idx=1; idx<numDirac(); idx++)
//       dirac_strides[idx] = size_t(4*(dirac_strides[idx-1]));
  }
  
  template< size_t L, size_t T >
  inline Propagator< L, T >::Propagator(Propagator< L, T > const &other)
    : d_components(other.d_components), psize(other.psize)
  {
    *d_references += 1;
  }

  template< size_t L, size_t T >
  inline Propagator< L, T >::~Propagator()
  {
    destroy();
  }
  
  
  
//     template< typename Element, size_t L, size_t T >
//     Core::Field< Element, L, T > loadILDG(std::string const &filename);
  template< size_t L, size_t T >
  inline bool Propagator< L, T >::loadILDG(std::vector< std::string > const filenames)
  {
//     if (nFiles == 1)
//     {
//       return true;
//     }
//     else 
    if (filenames.size() == 12)
    {
      for (size_t i=0; i<filenames.size(); i++)
      {
        // maybe reinterpret_cast< Core::Field< std::complex< double > > * > is needed here
        // better: explicit conversion routine
//         (*d_components)[i*12] = Tool::IO::loadILDG< QCD::Spinor, L, T >(filenames[i]);
      }
      return true;
    }
    else
    {
      std::cerr << "Error in void Propagator< L, T >::loadILDG(std::string const * const filenames, const size_t nFiles)" << std::endl;
      std::cerr << "filenames.size() should be 12" << std::endl;
      return false;
    }
  }
  
//   template< size_t L, size_t T >
//   inline void Propagator< L, T >::getStrides()
//   {
//     if (Colour > 0)
//     {
//       colour_strides = new size_t[Colour];
//       for (size_t idx = 0; idx<Colour; ++idx)
//         colour_strides[idx] = (size_t)pow(3, Colour-idx) * (size_t)pow(4, Dirac > idx ? Dirac-idx : 0);
//     }
//     else 
//       colour_strides = 0;
//     if (Dirac > 0)
//     {
//       dirac_strides = new size_t[Dirac];
//       for (size_t idx = 0; idx<Dirac; ++idx)
//         dirac_strides[idx] = (size_t)pow(3, Colour-idx < 0 ? 0 : Colour-idx+1) * (size_t)pow(4, Dirac-idx-1);
//     }
//     else 
//       dirac_strides = 0;
//   }
  
  template< size_t L, size_t T >
  inline typename Propagator< L, T >::template iterator<1> Propagator< L, T >::begin(Base::ColourIndex const idx, const size_t ColourID)
  {
    isolate();
    return iterator<1>(this(idx, ColourID).d_components);
  }

  template< size_t L, size_t T >
  inline typename Propagator< L, T >::template iterator<1> Propagator< L, T >::end(Base::ColourIndex const idx, const size_t ColourID)
  {
    isolate();
    return iterator<1>(this(idx, ColourID).d_components + size()/3);
  }
  
  template< size_t L, size_t T >
  inline typename Propagator< L, T >::template iterator<1> Propagator< L, T >::begin(Base::DiracIndex const idx, const size_t DiracID)
  {
    isolate();
    return iterator<1>(this(idx, DiracID).d_components);
  }
  
  template< size_t L, size_t T >
  inline typename Propagator< L, T >::template iterator<1> Propagator< L, T >::end(Base::DiracIndex const idx, const size_t DiracID)
  {
    isolate();
    return iterator<1>(this(idx, DiracID).d_components + size()/4);
  }

  template< size_t L, size_t T >
  inline size_t const Propagator< L, T >::size() const
  {
    return psize;
  }
  
  template< size_t L, size_t T >
  inline size_t const Propagator< L, T >::numDirac() const
  {
    return nDirac;
  }
  
  template< size_t L, size_t T >
  inline size_t const Propagator< L, T >::numColour() const
  {
    return nColour;
  }
  
}