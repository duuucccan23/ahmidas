namespace Core
{

  template< size_t L, size_t T >
  inline Propagator< L, T >::Propagator(size_t nCol, size_t nDir, bool alloc)
    : d_references(new size_t(1)),
      nDirac(new size_t(nDir)),
      nColour(new size_t(nCol)),
      psize((size_t)std::pow(4,nDir)*(size_t)std::pow(3,nCol)),
      colour_strides(new size_t[nCol]),
      dirac_strides(new size_t[nDir])
  {
    if(alloc)
    {
      d_components = new Field< std::complex< double >, L, T > *[size()];
      for (size_t idx=0; idx<size(); idx++)
        d_components[idx] = new Field< std::complex< double >, L, T >;
    }
    colour_strides[0] = 1;
    for (size_t idx=1; idx<numColour(); idx++)
      colour_strides[idx] = new size_t(3*(*colour_strides[idx-1]));
    
    dirac_strides[0] = (size_t)std::pow(3,numColour());
    for (size_t idx=1; idx<numDirac(); idx++)
      dirac_strides[idx] = new size_t(4*(*dirac_strides[idx-1]));
  }
  
  template< size_t L, size_t T >
  inline Propagator< L, T >::Propagator(Propagator< L, T > const &other)
    : d_components(other.d_components), psize(other.psize)
  {
    *d_references += 1;
  }

  template< size_t L, size_t T >
  inline Propagator< L, T >::Propagator(view< L, T > const &view)
  {
    Propagator tmp(*(view.nColour), *(view.nDirac));
    d_components = new Field< std::complex< double >, L, T > *[tmp.size()];
    for (size_t idx=0; idx<this.size(); idx++)
      d_components[idx] = new Field< std::complex< double >, L, T >(*(view.d_components[idx]));
  }

  template< size_t L, size_t T >
  inline Propagator< L, T >::~Propagator()
  {
    destroy();
  }
  
//   template< size_t L, size_t T >
//   inline void Propagator< L, T >::getStrides()
//   {
//     if (Colour > 0)
//     {
//       colour_strides = new size_t[Colour];
//       for (size_t idx = 0; idx<Colour; ++idx)
//         colour_strides[idx] = (size_t)pow(3, Colour-idx) * (size_t)pow(4, Dirac > idx ? Dirac-idx : 0);
//     }
//     else 
//       colour_strides = 0;
//     if (Dirac > 0)
//     {
//       dirac_strides = new size_t[Dirac];
//       for (size_t idx = 0; idx<Dirac; ++idx)
//         dirac_strides[idx] = (size_t)pow(3, Colour-idx < 0 ? 0 : Colour-idx+1) * (size_t)pow(4, Dirac-idx-1);
//     }
//     else 
//       dirac_strides = 0;
//   }
  
  template< size_t L, size_t T >
  inline typename Propagator< L, T >::template iterator<1> Propagator< L, T >::begin(Base::ColourIndex const idx, const size_t ColourID)
  {
    isolate();
    return iterator<1>(this(idx, ColourID).d_components);
  }

  template< size_t L, size_t T >
  inline typename Propagator< L, T >::template iterator<1> Propagator< L, T >::end(Base::ColourIndex const idx, const size_t ColourID)
  {
    isolate();
    return iterator<1>(this(idx, ColourID).d_components + size()/3);
  }
  
  template< size_t L, size_t T >
  inline typename Propagator< L, T >::template iterator<1> Propagator< L, T >::begin(Base::DiracIndex const idx, const size_t DiracID)
  {
    isolate();
    return iterator<1>(this(idx, DiracID).d_components);
  }
  
  template< size_t L, size_t T >
  inline typename Propagator< L, T >::template iterator<1> Propagator< L, T >::end(Base::DiracIndex const idx, const size_t DiracID)
  {
    isolate();
    return iterator<1>(this(idx, DiracID).d_components + size()/4);
  }

  template< size_t L, size_t T >
  inline size_t const Propagator< L, T >::size() const
  {
    return psize;
  }
  
  template< size_t L, size_t T >
  inline size_t const Propagator< L, T >::numDirac() const
  {
    return *nDirac;
  }
  
  template< size_t L, size_t T >
  inline size_t const Propagator< L, T >::numColour() const
  {
    return *nColour;
  }
  
  template< size_t L, size_t T >
  inline template view< L, T > &Propagator< L, T >::operator()(Base::DiracIndex const idx, size_t const DiracID)
  {
    return view< L, T >(this, idx, DiracID);
  }
  
  template< size_t L, size_t T >
  inline template view< L, T > &Propagator< L, T+1 >::operator()(Base::ColourIndex const idx, size_t const ColourID)
  {
    return view< L, T >(this, idx, ColourID);
  }
  
}
