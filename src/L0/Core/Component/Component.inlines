namespace Core
{
  template< typename Element, size_t L, size_t T, typename Atom >
  inline Component< Element, L, T, Atom >::Component(Field< Element, L, T > &parent, size_t const component)
    : d_weave(Base::Weave< L, T >::instance()), d_parent(parent), d_component(component)
  {}

  template< typename Element, size_t L, size_t T, typename Atom >
  inline Atom &Component< Element, L, T, Atom >::getMemoryIndex(size_t const idx)
  {
    return d_parent.getMemoryIndex(idx)[d_component];
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  inline Atom const &Component< Element, L, T, Atom >::getMemoryIndex(size_t const idx) const
  {
    return d_parent.getMemoryIndex(idx)[d_component];
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  inline Atom &Component< Element, L, T, Atom >::operator[](size_t const idx)
  {
    return d_parent[idx][d_component];
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  inline Atom const &Component< Element, L, T, Atom >::operator[](size_t const idx) const
  {
    return d_parent[idx][d_component];
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename Scalar >
  inline void Component< Element, L, T, Atom >::leftMultiply(Scalar const &other)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getMemoryIndex(idx).leftMultiply(other);
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename OtherElement >
  inline void Component< Element, L, T, Atom >::leftMultiply(Field< OtherElement, L, T > const &field)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getPhysicalIndex(idx).leftMultiply(field[idx]);
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename OtherElement, typename OtherAtom >
  void Component< Element, L, T, Atom >::leftMultiply(Component< OtherElement, L, T, OtherAtom > const &other)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getPhysicalIndex(idx).leftMultiply(other[idx]);
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename Scalar >
  inline void Component< Element, L, T, Atom >::rightMultiply(Scalar const &other)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getMemoryIndex(idx).rightMultiply(other);
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename OtherElement >
  inline void Component< Element, L, T, Atom >::rightMultiply(Field< OtherElement, L, T > const &field)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getPhysicalIndex(idx).rightMultiply(field[idx]);
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename OtherElement, typename OtherAtom  >
  inline void Component< Element, L, T, Atom >::rightMultiply(Component< OtherElement, L, T, OtherAtom > const &other)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getPhysicalIndex(idx).rightMultiply(other[idx]);
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename Scalar >
  inline Component< Element, L, T, Atom > &Component< Element, L, T, Atom >::operator+=(Scalar const &other)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getMemoryIndex(idx) += other;
    return *this;
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename OtherElement >
  inline Component< Element, L, T, Atom > &Component< Element, L, T, Atom >::operator+=(Field< OtherElement, L, T > const &field)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getPhysicalIndex(idx) += field[idx];
    return *this;
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename OtherElement, typename OtherAtom  >
  inline Component< Element, L, T, Atom > &Component< Element, L, T, Atom >::operator+=(Component< OtherElement, L, T, OtherAtom > const &other)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getPhysicalIndex(idx) += other[idx];
    return *this;
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename Scalar >
  inline Component< Element, L, T, Atom > &Component< Element, L, T, Atom >::operator-=(Scalar const &other)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getMemoryIndex(idx) -= other;
    return *this;
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename OtherElement >
  inline Component< Element, L, T, Atom > &Component< Element, L, T, Atom >::operator-=(Field< OtherElement, L, T > const &field)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getPhysicalIndex(idx) -= field[idx];
    return *this;
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename OtherElement, typename OtherAtom  >
  inline Component< Element, L, T, Atom > &Component< Element, L, T, Atom >::operator-=(Component< OtherElement, L, T, OtherAtom > const &other)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getPhysicalIndex(idx) -= other[idx];
    return *this;
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename Scalar >
  inline Component< Element, L, T, Atom > &Component< Element, L, T, Atom >::operator*=(Scalar const &other)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getMemoryIndex(idx) *= other;
    return *this;
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename OtherElement >
  inline Component< Element, L, T, Atom > &Component< Element, L, T, Atom >::operator*=(Field< OtherElement, L, T > const &field)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getPhysicalIndex(idx) *= field[idx];
    return *this;
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename OtherElement, typename OtherAtom >
  inline Component< Element, L, T, Atom > &Component< Element, L, T, Atom >::operator*=(Component< OtherElement, L, T, OtherAtom > const &other)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getPhysicalIndex(idx) *= other[idx];
    return *this;
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename Scalar >
  inline Component< Element, L, T, Atom > &Component< Element, L, T, Atom >::operator/=(Scalar const &other)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getMemoryIndex(idx) /= other;
    return *this;
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename OtherElement >
  inline Component< Element, L, T, Atom > &Component< Element, L, T, Atom >::operator/=(Field< OtherElement, L, T > const &field)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getPhysicalIndex(idx) /= field[idx];
    return *this;
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  template< typename OtherElement, typename OtherAtom >
  inline Component< Element, L, T, Atom > &Component< Element, L, T, Atom >::operator/=(Component< OtherElement, L, T, OtherAtom > const &other)
  {
    for (size_t idx = 0; idx < d_weave.localVolume(); ++idx)
      getPhysicalIndex(idx) /= other[idx];
    return *this;
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  inline hcComponent< Element, L, T, Atom > const Component< Element, L, T, Atom >::dagger() const
  {
    return hcComponent< Element, L, T, Atom >(*this);
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  inline typename Component< Element, L, T, Atom >::const_iterator Component< Element, L, T, Atom >::begin() const
  {
    return const_iterator(d_parent.begin(), d_component);
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  inline typename Component< Element, L, T, Atom >::const_iterator Component< Element, L, T, Atom >::end() const
  {
    return const_iterator(d_parent.end(), d_component);
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  inline typename Component< Element, L, T, Atom >::iterator Component< Element, L, T, Atom >::begin()
  {
    return iterator(d_parent.begin(), d_component);
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  inline typename Component< Element, L, T, Atom >::iterator Component< Element, L, T, Atom >::end()
  {
    return iterator(d_parent.end(), d_component);
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  inline Atom &Component< Element, L, T, Atom >::getPhysicalIndex(size_t const idx)
  {
    return d_parent[idx][d_component];
  }

  template< typename Element, size_t L, size_t T, typename Atom >
  inline Atom const &Component< Element, L, T, Atom >::getPhysicalIndex(size_t const idx) const
  {
    return d_parent[idx][d_component];
  }
}
