template< size_t L, size_t T >
void Tool::IO::saveScidac(Source::Stochastic < L, T > const &source, std::string const &basefilename, size_t timeIdx)
{
  //Rough error checking
  if (timeIdx < 0 || timeIdx >= T)
    return;

  //Setup filename (with proper 0 padding in case of long T dimension)
  std::ostringstream ostr(basefilename, std::ios::ate);
  ostr << "." << std::setw(static_cast< int >(std::floor(std::log10(T) + 1))) << std::setfill('0') << timeIdx << ".0";

  //Source::Stochastic holds SU3::Vectors, so 3 complex numbers per site = 6 floats
  size_t const slice = L * L * L;

  // The following snippet is probably overly cautious, but should be there for completeness' sake
  union {asFloat, asUInt32;} zero;
  zero.asFloat = 0.0;
  if (!Base::bigEndian)
    Base::swapEndian(&zero.asUInt32, &zero.asUInt32 + 1);

  // Check if the following hacks are allowed
//  static_assert(sizeof(uint32_t) == sizeof(float), "float and uint32_t are of different size");

  // Copy all values to a minimal local variable to perform endianness conversion
  uint32_t *smallfield = new uint32_t[6 * slice];
  double const *srcPtr = reinterpret_cast< double const* >(source.source());
  float *smallPtr = reinterpret_cast< float * >(smallfield);

  std::copy(srcPtr, srcPtr + 6 * slice, smallPtr);

  // Perform endianness conversion if needed
  if (!Base::bigEndian)
    Base::swapEndian(smallfield, smallfield + 6 * slice);

  // Setup an overly complete timeslicefield for writing out
  uint32_t *tempfield = new uint32_t[24 * slice + 18];
  std::fill_n(tempfield, 18, zero.asUInt32);

  uint32_t *base = tempfield + 18;
  for (size_t iter = 0; iter < slice; ++iter)
  {
    std::copy(smallfield + iter * 6, smallfield + (iter + 1) * 6, base + iter * 24);
    std::fill(base + iter * 24 + 6, base + (iter + 1) * 24, zero.asUInt32);
  }
  delete[] smallfield;

  // Prepare for calculation of Scidac checksum
  Base::ScidacChecksum scidac;

  // Loop over the 4 sourcefiles to make
  for (size_t srcIdx = 0; srcIdx < 4; ++srcIdx)
  {
    ostr << srcIdx; //Create full filename
    Tool::IO::Lime::Writer writer(ostr.str()); //Create Lime::Writer for this file

    writer.newRecord("scidac-binary-data");

    // Write out a leading block with zeroes
    writer.fill(zero.asUInt32, 24 * timeIdx * slice);
    size_t rank = scidac.blockAggregate(zero.asUInt32, 24, 24 * timeIdx * slice);

    // Copy in the timeslice we want, with proper zero padding
    writer.write(tempfield + (3 - srcIdx) * 6, 24 * slice);
    rank = scidac.blockAggregate(tempfield + (4 - srcIdx) * 6, 24 * slice, 24, rank);

    // Write out a closing block with zeroes
    writer.fill(zero.asUInt32, 24 * (T - timeIdx - 1) * slice);
    scidac.blockAggregate(zero.asUInt32, 24, 24 * (T - timeIdx - 1) * slice, rank);

    // Placeholder for serious storage of this quantity
    std::cout << "Scidac checksum for " << ostr.str() << ": " << std::hex << std::setw(8) << std::setfill('0')
              << scidac.lower() << ' ' << scidac.upper() << std::endl;
    scidac.clear(); // Reset checksum to zero
    ostr.seekp(-1, std::ios::cur); //Rewind the stream in preparation of the next name
  }

  delete[] tempfield;
}
