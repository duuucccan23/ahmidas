template< typename Element >
std::complex< double > Tool::tr(Core::Field < SU3::Matrix > const &field)
{
  std::complex< double > result(0.0, 0.0);
  for (Field< SU3::Matrix >::iterator iter = field->begin(); iter != field->end(); ++iter)
    result += iter->tr();

  return field.weave(result, wea_SUM) / field.volume();
}

template< typename Element >
double Tool::realtr(Core::Field< Element > const &field)
{
  double result(0.0);
  for (Field< SU3::Matrix >::iterator iter = field->begin(); iter != field->end(); ++iter)
    result += iter->realtr();

  return field.weave(result, wea_SUM) / field.volume();
}
std::complex < double > Tool::innerProduct(Core::Field< QCD::Spinor > const &left,
                                           Core::Field< QCD::Spinor > const &right,
                                           size_t tslice)
{
  size_t offset = tslice*left.spatialSize();
  std::complex < double > result(0.0, 0.0);
  for (size_t idx = offset; idx < left.spatialSize()+offset; ++idx)
    result += QCD::innerProduct(left.constMemoryIndex(idx), right.constMemoryIndex(idx));

  return result; // NOTE This should be made parallel with a gather call!
}
