namespace Core
{
  template< typename Element >
  template< size_t L, size_t T >
  inline Buffer< Element >::Buffer(Core::Grid< L, T > const &grid)
    : d_size(grid.localVolume()), d_data(new Element[d_size])
  {}

  template< typename Element >
  template< size_t L, size_t T >
  inline Buffer< Element >::Buffer(Core::Grid< L, T > const &grid, Element const &defValue)
    : d_size(grid.localVolume()), d_data(new Element[d_size])
  {
    std::fill(begin(), end(), defValue);
  }

  template< typename Element >
  inline Buffer< Element >::Buffer(Buffer< Element > &other) // Pilfers resources
    : d_size(other.d_size), d_data(other.d_data)
  {
    other.d_data = 0;
  }

  template< typename Element >
  inline Buffer< Element >::Buffer(Buffer< Element > &other, Element const &defValue) // Pilfers resources
    : d_size(other.d_size), d_data(other.d_data)
  {
    other.d_data = 0;
    std::fill(begin(), end(), defValue);
  }

  template< typename Element >
  inline Buffer< Element >::~Buffer()
  {
    delete[] d_data;
  }

  template< typename Element >
  inline typename Buffer< Element >::iterator Buffer< Element >::begin()
  {
    return d_data;
  }

  template< typename Element >
  inline typename Buffer< Element >::iterator Buffer< Element >::end()
  {
    return d_data + d_size;
  }

  template< typename Element >
  template< typename fType>
  inline void Buffer< Element >::leftMultiply(fType const &other)
  {
    typename fType::iterator otherItr = other.begin();
    for (iterator itr = begin(); itr != itr.end(); ++itr, ++otherItr)
      itr->leftMultiply(*otherItr);
  }

  template< typename Element >
  template< typename fType>
  inline void Buffer< Element >::rightMultiply(fType const &other)
  {
    typename fType::iterator otherItr = other.begin();
    for (iterator itr = begin(); itr != itr.end(); ++itr, ++otherItr)
      itr->rightMultiply(*otherItr);
  }
}
