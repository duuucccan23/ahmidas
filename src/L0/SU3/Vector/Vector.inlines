namespace SU3
{
  inline Vector::GeneralVector()
  {}

  inline Vector::GeneralVector(double const *data)
  {
    std::copy(data, data + 6, reinterpret_cast< double* >(d_data));
  }

  inline Vector::GeneralVector(std::complex< double > const *data)
  {
    std::copy(data, data + 3, d_data);
  }

  inline Vector::GeneralVector(Vector const &other)
  {
    std::copy(other.d_data, other.d_data + 3, d_data);
  }
  
  inline Vector::~GeneralVector()
  {}
  
  inline Vector &Vector::operator=(Vector const &other)
  {
    if (&other != this)
      std::copy(other.d_data, other.d_data + 3, d_data);
    return *this;
  }

  inline void SU3::Vector::setToRandom()
  {
    std::generate_n(reinterpret_cast< double* >(d_data), 6, Base::Random::fastSymmetric);
  }
  
  inline void SU3::Vector::setToZero()
  {
    std::fill_n(d_data, 3, std::complex< double >(0.0, 0.0));
  }
    
  inline Vector const &Vector::zero()
  {
    return s_zero;
  }

  template< typename T >
  inline Vector &Vector::operator+=(T const &rhand)
  {
    for (size_t idx = 0; idx < 3; ++idx)
      d_data[idx] += rhand;
    return *this;
  }
      
  template< >
  inline Vector &Vector::operator+=(Vector const &rhand)
  {
    for (size_t idx = 0; idx < 3; ++idx)
      d_data[idx] += rhand.d_data[idx];
    return *this;
  }

  template< typename T >
  inline Vector &Vector::operator-=(T const &rhand)
  {
    for (size_t idx = 0; idx < 3; ++idx)
      d_data[idx] -= rhand;
    return *this;
  }
      
  template< >
  inline Vector &Vector::operator-=(Vector const &rhand)
  {
    for (size_t idx = 0; idx < 3; ++idx)
      d_data[idx] -= rhand.d_data[idx];
    return *this;
  }

  template< typename T >
  inline Vector &Vector::operator*=(T const &rhand)
  {
    for (size_t idx = 0; idx < 3; ++idx)
      d_data[idx] *= rhand;
    return *this;
  }

  template< typename T >
  inline Vector &Vector::operator/=(T const &rhand)
  {
    for (size_t idx = 0; idx < 3; ++idx)
      d_data[idx] /= rhand;
    return *this;
  }
  
  inline std::complex< double > &Vector::operator[](short component)
  {
    return d_data[component];
  }
      
  inline std::complex< double > const &Vector::operator[](short component) const
  {
    return d_data[component];    
  }
  
  inline std::complex< double > innerProduct(Vector const &left, Vector const &right)
  {
    return std::conj(left[0]) * right[0] + std::conj(left[1]) * right[1] + std::conj(left[2]) * right[2];
  }

  inline size_t Vector::size() const
  {
    return 3;
  }
}
