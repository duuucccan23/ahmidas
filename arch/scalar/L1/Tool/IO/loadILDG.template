template< typename Element >
void Tool::IO::loadILDG(Core::Field< Element > *field, std::string const &filename)
{
  Lime::Reader reader(filename);
  if(!reader.good())
  {
    std::cerr << "Error occured trying to open file: " << filename << std::endl;
    exit(EXIT_FAILURE);
    return;
  }
  assert(reader.good());

  ILDGinfo info(reader);

  reader.retrieveRecord(reader.findRecord("ildg-binary-data"));
  if (reader.fail())
  {
    std::cerr << "Lime reader could not find a ildg-binary-data record in file: " << filename << std::endl;
    exit(EXIT_FAILURE);
    return;
  }
  assert(reader.good());

  Element *dataPtr = field->raw();
  Tool::ScidacChecksum calc(0);

  if (info.precision.compare("64") == 0)
  {
    reader.read(dataPtr, field->volume());
    calc.aggregate(dataPtr, field->volume(), 0);
    std::cerr << "Checksums for file " << filename << ".\n";
    std::cerr << "Calculated: " << std::hex << std::setfill('0') << std::setw(10) << std::internal << std::showbase << calc.lower() << ' ' << calc.upper() << ".\n";
    if (!Base::bigEndian)
      Base::swapEndian(dataPtr, dataPtr + field->volume(), sizeof(double));
  } else {
    size_t const elSize = sizeof(Element) / sizeof(double);
    uint32_t elem32[elSize];

    for (size_t ctr = 0; ctr < field->volume(); ++ctr, ++dataPtr)
    {
      reader.read(elem32, elSize);
      if (!Base::bigEndian)
        Base::swapEndian(elem32, elem32 + elSize);
      std::copy(reinterpret_cast< float* >(elem32), reinterpret_cast< float* >(elem32) + elSize,
                reinterpret_cast< double* >(dataPtr));
    }
  }

  reader.retrieveRecord(reader.findRecord("scidac-checksum"));
  if (reader.fail())
  {
    std::cerr << "Lime reader could not find a scidac-checksum record in file: " << filename << std::endl;
    exit(EXIT_FAILURE);
    return;
  }
  assert(reader.good());

  char mymesg[200];
  reader.read(mymesg, reader.recordSize());

  uint32_t reada;
  uint32_t readb;
  char *pos = strtok(mymesg, "<> \n\t");

  while (pos)
  {
    if (!strncmp(pos, "suma", 4)) {
      pos = strtok(0, "<> \n\t");
      sscanf(pos, "%x", &reada);
    }
    if (!strncmp(pos, "sumb", 4)) {
      pos = strtok(0, "<> \n\t");
      sscanf(pos, "%x", &readb);
    }
    pos = strtok(0, "<> \n\t");
  }
  std::cerr << "Read:       " << std::hex << std::showbase << std::internal << std::setfill('0') << std::setw(10) << reada << ' ' << readb << ".\n";

  if (reada != calc.lower() || readb != calc.upper()) {
    std::cerr << "WARNING! SciDAC checksum does not match!\n";
    exit(EXIT_FAILURE);
  }
}
