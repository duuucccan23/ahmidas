namespace QCD
{
  inline std::complex< double > tr(Tensor const &tensor)
  {
    return tensor.trace();
  }
  
  inline std::complex< double > tr(hcTensor const &tensor)
  {
    return std::conj(tensor.dagger().trace());
  }
  
  inline Tensor::Tensor()
  {
    std::fill_n(d_data, 144, std::complex< double >(0.0, 0.0));
  }

  inline Tensor::Tensor(Tensor const &other)
  {
    std::copy(other.d_data, other.d_data + 144, d_data);
  }

  inline Tensor::Tensor(std::complex< double > *data)
  {
    std::copy(data, data + 144, d_data);
  }

  inline std::complex< double > &Tensor::operator[](size_t const idx)
  {
    return d_data[idx];
  }

  inline std::complex< double > const &Tensor::operator[](size_t const idx) const
  {
    return d_data[idx];
  }
  
  inline std::complex< double > &Tensor::operator()(size_t dirSink, size_t colSink, size_t dirSource, size_t colSource)
  {
    return d_data[dirSink * 36 + colSink * 12 + dirSource * 4 + colSource];
  }
  
  inline std::complex< double > const &Tensor::operator()(size_t dirSink, size_t colSink, size_t dirSource, size_t colSource) const
  {
    return d_data[dirSink * 36 + colSink * 12 + dirSource * 4 + colSource];
  }

  inline hcTensor Tensor::dagger() const
  {
    return hcTensor(*this);
  }

  inline std::complex< double > Tensor::trace() const
  {
    return d_data[0] + d_data[13] + d_data[26] + d_data[39] + d_data[52] + d_data[65]
           + d_data[78] + d_data[91] + d_data[104] + d_data[117] + d_data[130] + d_data[143];
  }
}
