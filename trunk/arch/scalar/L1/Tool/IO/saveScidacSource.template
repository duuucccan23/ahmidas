template< size_t L, size_t T >
void Tool::IO::saveScidacSource(Source::Stochastic < L, T > const &source, std::string const &basefilename)
{
  std::ostringstream ostr(basefilename, std::ios::ate);
  ostr << std::setw(2) << std::setfill('0') << source.timeSlice() << ".0";
  size_t elements = L * L * L * 6; //I know these are SU3::Spinors, so 3 complex numbers per site

  //copy all values to a minimal local variable to perform endianness conversion
  float *smallfield = new float[elements];
  for (size_t iter = 0; iter < elements; ++iter)
    smallfield[iter] = *(source.source() + iter);
  if (!Base::bigEndian())
    Base::swapEndian(smallfield, smallfield + elements, sizeof(float));

  //setup an almost complete timeslicefield for writing out
  float *tempfield = new float[elements * 4 - 9];
  for (size_t iter = 0; iter < (L * L * L) - 1; ++iter) //NOTE THE MINUS 1 SHOULD BE THERE!
  {
    std::copy(smallfield + iter * 6, smallfield + (iter + 1) * 6, tempfield + iter * 24);
    std::fill(tempfield + iter * 24 + 6, tempfield + (iter + 1) * 24, 0.);
  }
  delete[] smallfield;

  //Prepare field of zeros for writing in the unused timeslices.
  float *zerofield = new float[elements * 4];
  std::fill(zerofield, zerofield + elements * 4, 0.);

  size_t timeSlice = source.timeSlice();
  for (size_t srcIdx = 0; srcIdx < 4; ++srcIdx)
  {
    ostr << srcIdx; //Create full filename
    Base::IO::Lime::Writer writer(ostr.str()); //Create Lime::Writer for this file

    writer.newRecord("scidac-binary-data");

    for (size_t t_iter = 0; t_iter < T; ++t_iter)
    {
      if (t_iter == timeSlice)
      {
        writer.write(zerofield, srcIdx * 6);
        writer.write(tempfield, L * L * L * 24 - 18);
        writer.write(zerofield, (3 - srcIdx) * 6);
        continue;
      }
      writer.write(zerofield, elements * 4);
    }
    ostr.seekp(-1, std::ios::cur); //prepare to remove the last number of the filename
  }
  delete[] tempfield;
  delete[] zerofield;
}
