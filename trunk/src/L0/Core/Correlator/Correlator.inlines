namespace Core
{

  inline Correlator::Correlator(Correlator const &other)
    : L(other.L), T(other.T), d_weave(other.d_weave), d_data(other.d_data),
      d_sumTimeslice(other.d_sumTimeslice), d_references(other.d_references)
  {
    *d_references += 1;
  }


  inline Correlator::Correlator(size_t const L_, size_t const T_, Core::Field<QCD::reducedTensor>* data)
    : L(L_), T(T_), d_weave(new Base::Weave(L_,T_)), d_data(data),
      d_sumTimeslice(new QCD::reducedTensor[T_]), d_references(new size_t(1))
  {
  }


  inline Correlator::~Correlator()
  {
    destroy();
  }


  inline QCD::reducedTensor &Correlator::operator[](size_t const t)
  {
    assert(t < T);
    return d_sumTimeslice[t];
  }


  inline QCD::reducedTensor const &Correlator::operator[](size_t const t) const
  {
    assert(t < T);
    return d_sumTimeslice[t];
  }


  // there must be some way to do this more efficiently!
  inline void Correlator::sumOverTimeSlices(size_t const *momentum)
  {
    if (momentum[0]==0 && momentum[1]==0 && momentum[2]==0)
    {
      sumOverTimeSlices();
      return;
    }
    isolate();
    std::complex< double > phase;
    const size_t zero(0);
    size_t x[3] = {0, 0, 0};
    size_t &x1 = x[0];
    size_t &x2 = x[1];
    size_t &x3 = x[1];
    size_t x4;
    for(x4=0; x4<T; x4++)
    {
      d_sumTimeslice[x4] = QCD::reducedTensor(std::complex< double >(0.0, 0.0));
      for(x3=0; x3<L; x3++)
      {
      for(x2=0; x2<L; x2++)
      {
      for(x1=0; x1<L; x1++)
      {
        if (d_weave->isLocallyAvailable(x1, x2, x3, x4))
        {
          phase = exp(  std::complex< double >(0, 2.*M_PI/double(L))
                      * double(std::inner_product(x, x+3, momentum, zero)));
          d_sumTimeslice[x4] += (*(d_data->at(x1, x2, x3, x4)))*phase;
        }
      }
      }
      }
    }
  }

  inline void Correlator::sumOverTimeSlices()
  {
    isolate();
    size_t x4, x1, x2, x3;
    for(x4=0; x4<T; x4++)
    {
      d_sumTimeslice[x4] = QCD::reducedTensor(std::complex< double >(0.0, 0.0));
      for(x3=0; x3<L; x3++)
      {
      for(x2=0; x2<L; x2++)
      {
      for(x1=0; x1<L; x1++)
      {
        if (d_weave->isLocallyAvailable(x1, x2, x3, x4))
        {
          d_sumTimeslice[x4] += (*(d_data->at(x1, x2, x3, x4)));
        }
      }
      }
      }
    }
  }

  inline std::complex< double > Correlator::getTrSum(size_t const timeslice)
  {
    assert(timeslice < T);
    return d_sumTimeslice[timeslice].trace();
  }

  inline size_t Correlator::getT() const
  {
    return T;
  }

  inline size_t Correlator::size() const
  {
    return d_weave->localSize(Base::idx_T);
  }

}
