namespace IO
{
  namespace Lime
  {
    inline void Reader::nextMessage()
    {
      retrieveRecord(d_messageIndices[d_currentRecord] + 1, 0);
    }

    inline void Reader::previousMessage()
    {
      retrieveRecord(d_messageIndices[d_currentRecord] - 1, 0);
    }

    inline void Reader::nextRecord()
    {
      d_fail = limeReaderNextRecord(d_reader);
    }

    inline void Reader::previousRecord()
    {
      d_fail = limeSetReaderPointer(d_reader, d_recordOffsets[--d_currentRecord]);
    }

    inline void Reader::retrieveRecord(int32_t const record)
    {
      retrieveRecord(d_messageIndices[d_currentRecord], record);
    }

    inline int Reader::fail() const
    {
      return d_fail;
    }

    inline uint32_t Reader::messages() const
    {
      return d_messageIndices.back();
    }

    inline uint32_t Reader::records() const
    {
      return std::count(d_messageIndices.begin(), d_messageIndices.end(), d_messageIndices[d_currentRecord]);
    }

    inline uint64_t Reader::size() const
    {
      return d_recordSizes[d_currentRecord];
    }

    inline uint32_t Reader::currentMessage() const
    {
      return d_messageIndices[d_currentRecord];
    }

    inline uint32_t Reader::currentRecord() const
    {
      return d_currentRecord;
    }

    inline std::string const &Reader::limeType() const
    {
      return d_limeTypes[d_currentRecord];
    }

    template< typename DataType >
    inline void Reader::read(DataType *data, uint64_t elements) const
    {
      read(reinterpret_cast< char* >(data), elements * sizeof(DataType));
    }
  }
}