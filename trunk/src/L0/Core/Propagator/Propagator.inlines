namespace Core
{

  template< size_t L, size_t T >
  inline Propagator< L, T >::Propagator(bool alloc)
    : d_references(new size_t(1)),
      colour_strides(new size_t[nColour]),
      dirac_strides(new size_t[nDirac]),
      psize((size_t)(std::pow(4.0, double(nDirac))*std::pow(3.0, double(nColour))))
  {

    colour_strides[0] = ColourStrideSink;
    colour_strides[1] = ColourStrideSource;
    dirac_strides[0]  = DiracStrideSink;
    dirac_strides[1]  = DiracStrideSource;

    if(alloc)
    {
      Field< std::complex< double >, L, T > *components = new Field< std::complex< double >, L, T > [size()];
      d_components = &components;
    }
  }


  template< size_t L, size_t T >
  inline Propagator< L, T >::Propagator(Propagator< L, T > const &other)
    : d_components(other.d_components), psize(other.psize)
  {
    *d_references += 1;
  }

  template< size_t L, size_t T >
  inline Propagator< L, T >::~Propagator()
  {
    destroy();
  }



//     template< typename Element, size_t L, size_t T >
//     Core::Field< Element, L, T > loadILDG(std::string const &filename);
  template< size_t L, size_t T >
  inline bool Propagator< L, T >::loadILDG(std::vector< std::string > const filenames)
  {
//     if (nFiles == 1)
//     {
//       return true;
//     }
//     else 
    if (filenames.size() == 12)
    {
      for (size_t i=0; i<filenames.size(); i++)
      {
        // maybe reinterpret_cast< Core::Field< std::complex< double > > * > is needed here
        // better: explicit conversion routine
//         (*d_components)[i*12] = Tool::IO::loadILDG< QCD::Spinor, L, T >(filenames[i]);
      }
      return true;
    }
    else
    {
      std::cerr << "Error in void Propagator< L, T >::loadILDG(std::string const * const filenames, const size_t nFiles)" << std::endl;
      std::cerr << "filenames.size() should be 12" << std::endl;
      return false;
    }
  }

  template< size_t L, size_t T >
  inline typename Propagator< L, T >::template iterator<1> Propagator< L, T >::begin(Base::ColourIndex const idx, size_t const Id)
  {
    isolate();
    assert(Id == 0 || Id == 1);
    return iterator<1>(*this, 0);
  }

  template< size_t L, size_t T >
  inline typename Propagator< L, T >::template iterator<1> Propagator< L, T >::end(Base::ColourIndex const idx, size_t const Id)
  {
    isolate();
    assert(Id == 0 || Id == 1);
    return iterator<1>(*this, 3);
  }

  template< size_t L, size_t T >
  inline typename Propagator< L, T >::template iterator<1> Propagator< L, T >::begin(Base::DiracIndex const idx, size_t const Id)
  {
    isolate();
    assert(Id == 0 || Id == 1);
    return iterator<1>(*this, 0);
  }

  template< size_t L, size_t T >
  inline typename Propagator< L, T >::template iterator<1> Propagator< L, T >::end(Base::DiracIndex const idx, size_t const Id)
  {
    isolate();
    assert(Id == 0 || Id == 1);
    return iterator<1>(*this, 4);
  }

  template< size_t L, size_t T >
  inline size_t const Propagator< L, T >::size() const
  {
    return psize;
  }

  template< size_t L, size_t T >
  inline size_t const Propagator< L, T >::numDirac() const
  {
    return nDirac;
  }

  template< size_t L, size_t T >
  inline size_t const Propagator< L, T >::numColour() const
  {
    return nColour;
  }











}