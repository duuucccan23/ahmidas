
#define __NO_INTERPOLATING_FIELD__

namespace Contract
{

  template< size_t IndexSrc, size_t IndexSnk >
  Core::Correlator light_meson_twopoint(Core::Propagator const *u, Core::Propagator const *d,
                                        Dirac::Gamma< IndexSrc > const &interpolSrc,
                                        Dirac::Gamma< IndexSnk > const &interpolSnk,
                                        size_t const *momentum)
  {
    if (d != 0)
    {
      assert(u->T() == d->T());
      assert(u->L() == d->L());
    }

    Core::Propagator *d_bar;


#ifdef __NO_INTERPOLATING_FIELD__

    std::cout << "\n ------ interpolating field left out ------ \n" << std::endl;
    d_bar = new Core::Propagator(*u);
    d_bar->dagger();
    Core::Correlator twopoint_nif(u->L(), u->T(), (*u)*(*d_bar));
    twopoint_nif.sumOverTimeSlices();
    for (size_t t=0; t<twopoint_nif.getT(); t++)
    {
      std::cout << t << "  " << std::scientific << std::setprecision(10) << std::showpos
                << tr(twopoint_nif[t]).real() << "  " << tr(twopoint_nif[t]).imag() << std::endl;
//       if (t==twopoint_nif.getT()-1)
//       {
//         std::cout << " = trace of" << std::endl;
//         std::cout << twopoint_nif[t]   << std::endl;
//       }
    }
    std::cout << "\n ------------------------------------------ \n" << std::endl;
    delete d_bar;
#endif

    d_bar = new Core::Propagator(*u);
    d_bar->revert();

    Core::Propagator tmpU((*u)*interpolSnk);
    Core::Propagator tmpD((*d_bar)*interpolSrc);

    delete d_bar;

    Core::Correlator twopoint(u->L(), u->T(), tmpU*tmpD);

    twopoint.sumOverTimeSlices();

    for (size_t t=0; t<twopoint.getT(); t++)
    {
      std::cout << t << "  " << std::scientific << std::setprecision(10) << std::showpos
                << tr(twopoint[t]).real() << "  " << tr(twopoint[t]).imag() << std::endl;
//       if (t==twopoint.getT()-1)
//       {
//         std::cout << " = trace of" << std::endl;
//         std::cout << twopoint[t]   << std::endl;
//       }
    }
    return twopoint;
  }



  template< size_t IndexSrc, size_t IndexSnk >
  inline Core::Correlator light_meson_twopoint(Core::Propagator const *u, Core::Propagator const *d,
                                               Dirac::Gamma< IndexSrc > const &interpolSrc,
                                               Dirac::Gamma< IndexSnk > const &interpolSnk)
  {
    // zero momentum projection
    size_t const p[3] = {0, 0, 0};
    return light_meson_twopoint(u, d, interpolSrc, interpolSnk, p);
  }



  // this works using the one-end trick and gives all 16 gamma-combinations
  inline std::vector< Core::Correlator > light_meson_twopoint_stochastic(Core::StochasticPropagator< 4 > const &psi1,
                                                                          Core::StochasticPropagator< 4 > const &psi2)
  {
    assert(psi1.T() == psi2.T() && psi1.L() == psi2.L());

    std::vector< Core::Correlator > twopoints;

    Core::StochasticPropagator< 4 > psi2_dagger(psi2);
    psi2_dagger.dagger();

    Dirac::Gamma< 5 >  gamma5;
    Dirac::Gamma< 4 >  gamma0;
    Dirac::Gamma< 1 >  gamma1;
    Dirac::Gamma< 2 >  gamma2;
    Dirac::Gamma< 3 >  gamma3;
    Dirac::Unity       one;
    Dirac::Gamma< 45 > gamma0gamma5;
    Dirac::Gamma< 15 > gamma1gamma5;
    Dirac::Gamma< 25 > gamma2gamma5;
    Dirac::Gamma< 35 > gamma3gamma5;
    Dirac::Gamma< 54 > gamma5gamma0;
    Dirac::Gamma< 51 > gamma5gamma1;
    Dirac::Gamma< 52 > gamma5gamma2;
    Dirac::Gamma< 53 > gamma5gamma3;
    Dirac::Sigma< 41 > sigma01;
    Dirac::Sigma< 42 > sigma02;
    Dirac::Sigma< 43 > sigma03;
    Dirac::Sigma< 12 > sigma12;
    Dirac::Sigma< 13 > sigma13;
    Dirac::Sigma< 23 > sigma23;

    Core::StochasticPropagator< 4 > *gamma5_Gamma_psi1;
    Core::StochasticPropagator< 4 > *gamma5_Gamma_psi2_dagger;
    Core::Correlator *twopoint;

    // SD: I consider it to be faster to multiply the Gamma to the source indices (Gamma from the right),
    // moreover, this enables us to use the faster '*=' operator instead of '*'

    // ------ Gamma = gamma5 ------
    gamma5_Gamma_psi1        = new Core::StochasticPropagator< 4 >(psi1);
    gamma5_Gamma_psi2_dagger = new Core::StochasticPropagator< 4 >(psi2_dagger);
    twopoint = new Core::Correlator(psi1.L(), psi2.T(), (*gamma5_Gamma_psi1)*(*gamma5_Gamma_psi2_dagger));
    twopoint->sumOverTimeSlices();
    twopoints.push_back(*twopoint);
    delete twopoint;
    delete gamma5_Gamma_psi1;
    delete gamma5_Gamma_psi2_dagger;

    // ------ Gamma = gamma0 ------
    gamma5_Gamma_psi1        = new Core::StochasticPropagator< 4 >(psi1);
    (*gamma5_Gamma_psi1) *= gamma0gamma5;
    gamma5_Gamma_psi2_dagger = new Core::StochasticPropagator< 4 >(psi2_dagger);
    (*gamma5_Gamma_psi2_dagger) *= gamma5gamma0;
    twopoint = new Core::Correlator(psi1.L(), psi2.T(), (*gamma5_Gamma_psi1)*(*gamma5_Gamma_psi2_dagger));
    twopoint->sumOverTimeSlices();
    twopoints.push_back(*twopoint);
    delete twopoint;
    delete gamma5_Gamma_psi1;
    delete gamma5_Gamma_psi2_dagger;



    for  (size_t idx=0; idx<twopoints.size(); idx++)
    {
      std::cout << "\nGamma combination index " << idx << " \n" << std::endl;
      for (size_t t=0; t<psi1.T(); t++)
      {
        std::cout << t << "  " << std::scientific << std::setprecision(10) << std::showpos
          << tr((twopoints[idx])[t]).real() << "  " << tr((twopoints[idx])[t]).imag() << std::endl;
      }
    }
    std::cout<< std::endl;

    return twopoints;
  }



}
