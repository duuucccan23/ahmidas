namespace Core
{
  template< typename Element, size_t L, size_t T >
  inline Field< Element, L, T >::Field(Grid< L, T > &grid)
  : d_grid(grid), d_bufferSize(0), d_buffer(0),
    d_field(new Element[d_grid.localVolume()])
  {
    std::fill(d_offsets, d_offsets + 4, 0);
    setSurfaces();
  }

  template< typename Element, size_t L, size_t T >
  inline Field< Element, L, T >::~Field()
  {
    delete[] d_buffer;
    delete[] d_field;
  }

  template< typename Element, size_t L, size_t T >
  inline Grid< L, T > const &Field< Element, L, T >::grid() const
  {
    return d_grid;
  }

  template< typename Element, size_t L, size_t T >
  inline typename Field< Element, L, T >::iterator Field< Element, L, T >::begin()
  {
    short start[] = {0, 0, 0, 0};
    return iterator(*this, start);
  }

  template< typename Element, size_t L, size_t T >
  inline typename Field< Element, L, T >::iterator Field< Element, L, T >::end()
  {
    short finish[] = {d_grid.dim(idx_T), 0, 0, 0};
    return iterator(*this, finish);
  }

  template< typename Element, size_t L, size_t T >
  template< typename Atom >
  inline Component< Element, L, T, Atom > Field< Element, L, T >::component(size_t idx)
  {
    return FieldComponent(*this, idx);
  }

  template< typename Element, size_t L, size_t T >
  inline void Field< Element, L, T >::reunitarize()
  {
    for (iterator iter = begin(); iter != end(); ++iter)
      iter->reunitarize();
  }

  template< typename Element, size_t L, size_t T >
  template< typename Type >
  inline void Field< Element, L, T >::leftMultiply(Field< Type, L, T > const &other)
  {
    typename Field< Type, L, T >::iterator hisIter = other.begin();
    for (iterator myIter = begin(); myIter != end(); ++myIter, ++hisIter)
      myIter->leftMultiply(*hisIter);
  }

  template< typename Element, size_t L, size_t T >
  template< typename Type >
  inline void Field< Element, L, T >::rightMultiply(Field< Type, L, T > const &other)
  {
    typename Field< Type, L, T >::iterator hisIter = other.begin();
    for (iterator myIter = begin(); myIter != end(); ++myIter, ++hisIter)
      myIter->rightMultiply(*hisIter);
  }

  template< typename Element, size_t L, size_t T >
  template< typename Type >
  inline Field< Element, L, T > &Field< Element, L, T >::operator+=(Type const &rhand)
  {
    for (Element *iter = d_field; iter != d_field + d_grid.volume(); ++iter)
      *iter += rhand;
  }

  template< typename Element, size_t L, size_t T >
  template< typename Type >
  Field< Element, L, T > &Field< Element, L, T >::operator+=(Field< Type, L, T > const &other)
  {
    typename Field< Type, L, T >::iterator hisIter = other.begin();
    for (iterator myIter = begin(); myIter != end(); ++myIter, ++hisIter)
      *myIter += *hisIter;
  }

  template< typename Element, size_t L, size_t T >
  template< typename Type >
  Field< Element, L, T > &Field< Element, L, T >::operator-=(Type const &rhand)
  {
    for (Element *iter = d_field; iter != d_field + d_grid.volume(); ++iter)
      *iter -= rhand;
  }

  template< typename Element, size_t L, size_t T >
  template< typename Type >
  Field< Element, L, T > &Field< Element, L, T >::operator-=(Field< Type, L, T > const &other)
  {
    typename Field< Type, L, T >::iterator hisIter  = other.begin();
    for (iterator myIter = begin(); myIter != end(); ++myIter, ++hisIter)
      *myIter -= *hisIter;
  }

  template< typename Element, size_t L, size_t T >
  template< typename Type >
  Field< Element, L, T > &Field< Element, L, T >::operator*=(Type const &rhand)
  {
    for (Element *iter = d_field; iter != d_field + d_grid.volume(); ++iter)
      *iter *= rhand;
  }

  template< typename Element, size_t L, size_t T >
  template< typename Type >
  Field< Element, L, T > &Field< Element, L, T >::operator*=(Field< Type, L, T > const &other)
  {
    typename Field< Type, L, T >::iterator hisIter = other.begin();
    for (iterator myIter = begin(); myIter != end(); ++myIter, ++hisIter)
      *myIter *= *hisIter;
  }

  template< typename Element, size_t L, size_t T >
  template< typename Type >
  Field< Element, L, T > &Field< Element, L, T >::operator/=(Type const &rhand)
  {
    for (Element *iter = d_field; iter != d_field + d_grid.volume(); ++iter)
      *iter /= rhand;
  }

  template< typename Element, size_t L, size_t T >
  inline Element &Field< Element, L, T >::element(short const *idx)
  {
    return d_field[  (((idx[idx_T] + d_offsets[idx_T]) % d_grid.dim(idx_T)) * d_grid.cumDim(idx_T))
                   + (((idx[idx_X] + d_offsets[idx_X]) % d_grid.dim(idx_X)) * d_grid.cumDim(idx_X))
                   + (((idx[idx_Y] + d_offsets[idx_Y]) % d_grid.dim(idx_Y)) * d_grid.cumDim(idx_Y))
                   + (((idx[idx_Z] + d_offsets[idx_Z]) % d_grid.dim(idx_Z)) * d_grid.cumDim(idx_Z))];
  }
}
