namespace QCD
{

  inline std::complex< double > tr(Tensor const &tensor)
  {
    return tensor.trace();
  }

  inline std::complex< double > tr(hcTensor const &tensor)
  {
    return std::conj(tensor.dagger().trace());
  }

  inline Tensor::Tensor()
  {
    std::fill_n(d_data, 144, std::complex< double >(0.0, 0.0));
  }

  inline Tensor::Tensor(Tensor const &other)
  {
    std::copy(other.d_data, other.d_data + 144, d_data);
  }

  inline Tensor::Tensor(Spinor *data[12])
  {
    for (size_t ic=0; ic < 12; ic++)
      std::copy(reinterpret_cast< std::complex< double >* >(data[ic]),
                reinterpret_cast< std::complex< double >* >(data[ic]) + 12,
                d_data + ic*12);
  }

  inline Tensor::Tensor(Dirac::Matrix const * const data[9])
  {
    static size_t const color_table[9] = {
      3*Base::col_RED   + Base::col_RED, 3*Base::col_RED   + Base::col_GREEN, 3*Base::col_RED   + Base::col_BLUE,
      3*Base::col_GREEN + Base::col_RED, 3*Base::col_GREEN + Base::col_GREEN, 3*Base::col_GREEN + Base::col_BLUE,
      3*Base::col_BLUE  + Base::col_RED, 3*Base::col_BLUE  + Base::col_GREEN, 3*Base::col_BLUE  + Base::col_BLUE};
    static size_t const tensor_color_table[9] = {
      12*Base::col_RED   + Base::col_RED, 12*Base::col_RED   + Base::col_GREEN, 12*Base::col_RED   + Base::col_BLUE,
      12*Base::col_GREEN + Base::col_RED, 12*Base::col_GREEN + Base::col_GREEN, 12*Base::col_GREEN + Base::col_BLUE,
      12*Base::col_BLUE  + Base::col_RED, 12*Base::col_BLUE  + Base::col_GREEN, 12*Base::col_BLUE  + Base::col_BLUE};

    std::complex< double >* data_ptr(NULL);
    std::complex< double > const * rT_ptr(NULL);

    for (size_t idx=0; idx<9; idx++)
    {
      data_ptr = d_data + tensor_color_table[idx];
      rT_ptr = &((*(data[color_table[idx]]))[0]);

      data_ptr[  0] = rT_ptr[ 0];
      data_ptr[  3] = rT_ptr[ 1];
      data_ptr[  6] = rT_ptr[ 2];
      data_ptr[  9] = rT_ptr[ 3];
      data_ptr[ 36] = rT_ptr[ 4];
      data_ptr[ 39] = rT_ptr[ 5];
      data_ptr[ 42] = rT_ptr[ 6];
      data_ptr[ 45] = rT_ptr[ 7];
      data_ptr[ 72] = rT_ptr[ 8];
      data_ptr[ 75] = rT_ptr[ 9];
      data_ptr[ 78] = rT_ptr[10];
      data_ptr[ 81] = rT_ptr[11];
      data_ptr[108] = rT_ptr[12];
      data_ptr[111] = rT_ptr[13];
      data_ptr[114] = rT_ptr[14];
      data_ptr[117] = rT_ptr[15];
    }
  }


  inline hcTensor Tensor::dagger() const
  {
    return hcTensor(*this);
  }

  inline void Tensor::conjugate()
  {
    for(size_t i=0; i < 144; i++)
      d_data[i] = conj(d_data[i]);
    // there must be a better way to do this using std::transform (the following example does not work):
    // std::transform(d_data, d_data + 144, d_data, std::ptr_fun(&conj));
  }


  inline void Tensor::transposeDirac()
  {
    // only swap non-diagonal SU3 (colour) vectors
    std::swap_ranges(d_data +   3, d_data +   6, d_data +  36);
    std::swap_ranges(d_data +   6, d_data +   9, d_data +  72);
    std::swap_ranges(d_data +   9, d_data +  12, d_data + 108);

    std::swap_ranges(d_data +  15, d_data +  18, d_data +  48);
    std::swap_ranges(d_data +  18, d_data +  21, d_data +  84);
    std::swap_ranges(d_data +  21, d_data +  24, d_data + 120);

    std::swap_ranges(d_data +  27, d_data +  30, d_data +  60);
    std::swap_ranges(d_data +  30, d_data +  33, d_data +  96);
    std::swap_ranges(d_data +  33, d_data +  36, d_data + 132);

    std::swap_ranges(d_data +  42, d_data +  45, d_data +  75);
    std::swap_ranges(d_data +  45, d_data +  48, d_data + 111);

    std::swap_ranges(d_data +  54, d_data +  57, d_data +  87);
    std::swap_ranges(d_data +  57, d_data +  60, d_data + 123);

    std::swap_ranges(d_data +  66, d_data +  69, d_data +  99);
    std::swap_ranges(d_data +  69, d_data +  72, d_data + 135);

    std::swap_ranges(d_data +  81, d_data +  84, d_data + 114);

    std::swap_ranges(d_data +  93, d_data +  96, d_data + 126);

    std::swap_ranges(d_data + 105, d_data + 108, d_data + 138);
  }

  inline void Tensor::transposeFull()
  {
    // only swap non-diagonal elements
    std::swap(*(d_data +   1), *(d_data +  12));
    std::swap(*(d_data +   2), *(d_data +  24));
    std::swap(*(d_data +   3), *(d_data +  36));
    std::swap(*(d_data +   4), *(d_data +  48));
    std::swap(*(d_data +   5), *(d_data +  60));
    std::swap(*(d_data +   6), *(d_data +  72));
    std::swap(*(d_data +   7), *(d_data +  84));
    std::swap(*(d_data +   8), *(d_data +  96));
    std::swap(*(d_data +   9), *(d_data + 108));
    std::swap(*(d_data +  10), *(d_data + 120));
    std::swap(*(d_data +  11), *(d_data + 132));
    // ---
    std::swap(*(d_data +  14), *(d_data +  25));
    std::swap(*(d_data +  15), *(d_data +  37));
    std::swap(*(d_data +  16), *(d_data +  49));
    std::swap(*(d_data +  17), *(d_data +  61));
    std::swap(*(d_data +  18), *(d_data +  73));
    std::swap(*(d_data +  19), *(d_data +  85));
    std::swap(*(d_data +  20), *(d_data +  97));
    std::swap(*(d_data +  21), *(d_data + 109));
    std::swap(*(d_data +  22), *(d_data + 121));
    std::swap(*(d_data +  23), *(d_data + 133));
    // ---
    std::swap(*(d_data +  27), *(d_data +  38));
    std::swap(*(d_data +  28), *(d_data +  50));
    std::swap(*(d_data +  29), *(d_data +  62));
    std::swap(*(d_data +  30), *(d_data +  74));
    std::swap(*(d_data +  31), *(d_data +  86));
    std::swap(*(d_data +  32), *(d_data +  98));
    std::swap(*(d_data +  33), *(d_data + 110));
    std::swap(*(d_data +  34), *(d_data + 122));
    std::swap(*(d_data +  35), *(d_data + 134));
    // ---
    std::swap(*(d_data +  40), *(d_data +  51));
    std::swap(*(d_data +  41), *(d_data +  63));
    std::swap(*(d_data +  42), *(d_data +  75));
    std::swap(*(d_data +  43), *(d_data +  87));
    std::swap(*(d_data +  44), *(d_data +  99));
    std::swap(*(d_data +  45), *(d_data + 111));
    std::swap(*(d_data +  46), *(d_data + 123));
    std::swap(*(d_data +  47), *(d_data + 135));
    // ---
    std::swap(*(d_data +  53), *(d_data +  64));
    std::swap(*(d_data +  54), *(d_data +  76));
    std::swap(*(d_data +  55), *(d_data +  88));
    std::swap(*(d_data +  56), *(d_data + 100));
    std::swap(*(d_data +  57), *(d_data + 112));
    std::swap(*(d_data +  58), *(d_data + 124));
    std::swap(*(d_data +  59), *(d_data + 136));
    // ---
    std::swap(*(d_data +  66), *(d_data +  77));
    std::swap(*(d_data +  67), *(d_data +  89));
    std::swap(*(d_data +  68), *(d_data + 101));
    std::swap(*(d_data +  69), *(d_data + 113));
    std::swap(*(d_data +  70), *(d_data + 125));
    std::swap(*(d_data +  71), *(d_data + 137));
    // ---
    std::swap(*(d_data +  79), *(d_data +  90));
    std::swap(*(d_data +  80), *(d_data + 102));
    std::swap(*(d_data +  81), *(d_data + 114));
    std::swap(*(d_data +  82), *(d_data + 126));
    std::swap(*(d_data +  83), *(d_data + 138));
    // ---
    std::swap(*(d_data +  92), *(d_data + 103));
    std::swap(*(d_data +  93), *(d_data + 115));
    std::swap(*(d_data +  94), *(d_data + 127));
    std::swap(*(d_data +  95), *(d_data + 139));
    // ---
    std::swap(*(d_data + 105), *(d_data + 116));
    std::swap(*(d_data + 106), *(d_data + 128));
    std::swap(*(d_data + 107), *(d_data + 140));
    // ---
    std::swap(*(d_data + 118), *(d_data + 129));
    std::swap(*(d_data + 119), *(d_data + 141));
    // ---
    std::swap(*(d_data + 131), *(d_data + 142));
  }



  inline std::complex< double > Tensor::trace() const
  {
    return d_data[0] + d_data[13] + d_data[26] + d_data[39] + d_data[52] + d_data[65]
           + d_data[78] + d_data[91] + d_data[104] + d_data[117] + d_data[130] + d_data[143];
  }

  inline size_t Tensor::size() const
  {
    return 144;
  }

  inline std::complex< double > Tensor::diff(Tensor const &other) const
  {
    std::complex< double > initial(0.0, 0.0);
    std::complex< double > final = std::accumulate(d_data, d_data+144, initial);
    final -= std::accumulate(other.d_data, other.d_data+144, initial);
    return final;
  }

  inline void Tensor::setToRandom()
  {
    std::generate_n(reinterpret_cast< double* >(d_data), 288, Base::Random::fastSymmetric);
  }

  inline void Tensor::setToRandom_Z4(Base::SourcePolarization const DState, Base::SourceColorState const CState)
  {
    std::fill_n(d_data, 144, std::complex< double >(0, 0));
    std::complex< double > tmp_data [12];
    std::generate_n(reinterpret_cast< double* >(tmp_data), 24, Base::Random::Z2);
    switch (DState)
    {
      // case Base::sou_UNPOLARIZED:
      case Base::sou_PARTLY_POLARIZED:
        switch (CState)
        {
          case Base::sou_GENERIC:
            std::copy(tmp_data, tmp_data + 12, d_data);
            std::copy(tmp_data, tmp_data + 12, d_data +  12);
            std::copy(tmp_data, tmp_data + 12, d_data +  24);
            std::copy(tmp_data, tmp_data + 12, d_data +  36);
            std::copy(tmp_data, tmp_data + 12, d_data +  48);
            std::copy(tmp_data, tmp_data + 12, d_data +  60);
            std::copy(tmp_data, tmp_data + 12, d_data +  72);
            std::copy(tmp_data, tmp_data + 12, d_data +  84);
            std::copy(tmp_data, tmp_data + 12, d_data +  96);
            std::copy(tmp_data, tmp_data + 12, d_data + 108);
            std::copy(tmp_data, tmp_data + 12, d_data + 120);
            std::copy(tmp_data, tmp_data + 12, d_data + 132);
            break;
          default:
          std::cerr << "This Base::SourceColorState is not implemented in Tensor::setToRandom_Z4()\n";
          std::cerr << "Aborting ..." << std::endl;
          exit(1);
        }
        break;
      case Base::sou_FULLY_POLARIZED:
        switch (CState)
        {
          // this is what is called spin diluted
          case Base::sou_GENERIC:
            std::copy(tmp_data,     tmp_data +  3, d_data);
            std::copy(tmp_data,     tmp_data +  3, d_data +  12);
            std::copy(tmp_data,     tmp_data +  3, d_data +  24);
            std::copy(tmp_data + 3, tmp_data +  6, d_data +  39);
            std::copy(tmp_data + 3, tmp_data +  6, d_data +  51);
            std::copy(tmp_data + 3, tmp_data +  6, d_data +  63);
            std::copy(tmp_data + 6, tmp_data +  9, d_data +  78);
            std::copy(tmp_data + 6, tmp_data +  9, d_data +  90);
            std::copy(tmp_data + 6, tmp_data +  9, d_data + 102);
            std::copy(tmp_data + 9, tmp_data + 12, d_data + 117);
            std::copy(tmp_data + 9, tmp_data + 12, d_data + 129);
            std::copy(tmp_data + 9, tmp_data + 12, d_data + 141);
            break;
          // this is what is called spin and color diluted
          case Base::sou_PURE:
            d_data[  0] = tmp_data[ 0];
            d_data[ 13] = tmp_data[ 1];
            d_data[ 26] = tmp_data[ 2];
            d_data[ 39] = tmp_data[ 3];
            d_data[ 52] = tmp_data[ 4];
            d_data[ 65] = tmp_data[ 5];
            d_data[ 78] = tmp_data[ 6];
            d_data[ 91] = tmp_data[ 7];
            d_data[104] = tmp_data[ 8];
            d_data[117] = tmp_data[ 9];
            d_data[130] = tmp_data[10];
            d_data[143] = tmp_data[11];
            break;
          default:
          std::cerr << "This Base::SourceColorState is not implemented in Tensor::setToRandom_Z4()\n";
          std::cerr << "Aborting ..." << std::endl;
          exit(1);
        }
        break;
      default:
      std::cerr << "This Base::SourcePolarization is not implemented in Tensor::setToRandom_Z4()\n";
      std::cerr << "Aborting ..." << std::endl;
      exit(1);
    }
  }

  inline Tensor::iterator Tensor::begin(Base::ColourIndex const idx, TensorColourStride const stride)
  {
    return iterator(*this, stride, 0);
  }


  inline Tensor::iterator Tensor::end(Base::ColourIndex const idx, TensorColourStride const stride)
  {
    return iterator(*this, stride, size());
  }


  inline Tensor::iterator Tensor::begin(Base::DiracIndex const idx, TensorDiracStride const stride)
  {
    return iterator(*this, stride, 0);
  }


  inline Tensor::iterator Tensor::end(Base::DiracIndex const idx, TensorDiracStride const stride)
  {
    return iterator(*this, stride ,size());
  }

  inline std::ostream &operator<<(std::ostream &out, Tensor const &tensor)
  {
    out <<  Spinor(tensor.d_data)       << Spinor(tensor.d_data +  12) << Spinor(tensor.d_data +  24);
    out <<  Spinor(tensor.d_data +  36) << Spinor(tensor.d_data +  48) << Spinor(tensor.d_data +  60);
    out <<  Spinor(tensor.d_data +  72) << Spinor(tensor.d_data +  84) << Spinor(tensor.d_data +  96);
    out <<  Spinor(tensor.d_data + 108) << Spinor(tensor.d_data + 120) << Spinor(tensor.d_data + 132) << std::endl;
    return out;
  }



  /* ############################################################################################## */
  /* ############################################################################################## */
  /* ############################################################################################## */


inline void Tensor::left_multiply_proton()
  {

// this would be the corresponding Gamma structure
//   template< >
//   size_t const Gamma< 245 >::s_perm[4] = {1, 0, 3, 2};
//   template< >
//   std::complex< double > const Gamma< 245 >::s_sign[4] = {1, -1, 1, -1};

    std::swap_ranges(d_data,      d_data +  36, d_data +  36);
    std::swap_ranges(d_data + 72, d_data + 108, d_data + 108);
    // actually we have -Gamma2*Gamma0*Gamma5, which is considered below
    std::transform(d_data,       d_data +  36, d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), std::complex< double >(0, -1)));
    std::transform(d_data +  36, d_data +  72, d_data +  36,
                   std::bind1st(std::multiplies< std::complex< double > >(), std::complex< double >(0, +1)));
    std::transform(d_data +  72, d_data + 108, d_data +  72,
                   std::bind1st(std::multiplies< std::complex< double > >(), std::complex< double >(0, -1)));
    std::transform(d_data + 108, d_data + 144, d_data + 108,
                   std::bind1st(std::multiplies< std::complex< double > >(), std::complex< double >(0, +1)));
  }


  inline void Tensor::right_multiply_proton()
  {
    std::complex< double > *spinor_data = NULL;
    // personal note: if this turns out to work, don't use spinor interface but d_data directly
    for(size_t Idx=0; Idx<12; Idx++)
    {
      spinor_data = d_data + Idx*12;
      std::swap_ranges(spinor_data    , spinor_data + 3, spinor_data + 3);
      std::swap_ranges(spinor_data + 6, spinor_data + 9, spinor_data + 9);
      std::transform(spinor_data,     spinor_data +  3, spinor_data,
                     std::bind1st(std::multiplies< std::complex< double > >(), std::complex< double >(0, +1)));
      std::transform(spinor_data + 3, spinor_data +  6, spinor_data + 3,
                     std::bind1st(std::multiplies< std::complex< double > >(), std::complex< double >(0, -1)));
      std::transform(spinor_data + 6, spinor_data +  9, spinor_data + 6,
                     std::bind1st(std::multiplies< std::complex< double > >(), std::complex< double >(0, +1)));
      std::transform(spinor_data + 9, spinor_data + 12, spinor_data + 9,
                     std::bind1st(std::multiplies< std::complex< double > >(), std::complex< double >(0, -1)));
    }
  }




  inline void Tensor::getDiracMatrix(Dirac::Matrix &dMatrix, Base::ColourIndex const colour_src, Base::ColourIndex const colour_snk) const
  {
    size_t index = 12*colour_src + colour_snk;
    dMatrix[ 0] = d_data[index     ];
    dMatrix[ 1] = d_data[index +   3];
    dMatrix[ 2] = d_data[index +   6];
    dMatrix[ 3] = d_data[index +   9];
    dMatrix[ 4] = d_data[index +  36];
    dMatrix[ 5] = d_data[index +  39];
    dMatrix[ 6] = d_data[index +  42];
    dMatrix[ 7] = d_data[index +  45];
    dMatrix[ 8] = d_data[index +  72];
    dMatrix[ 9] = d_data[index +  75];
    dMatrix[10] = d_data[index +  78];
    dMatrix[11] = d_data[index +  81];
    dMatrix[12] = d_data[index + 108];
    dMatrix[13] = d_data[index + 111];
    dMatrix[14] = d_data[index + 114];
    dMatrix[15] = d_data[index + 117];
  }



  /* the following constructors are used to perform contractions */

  inline void getDiracMatrix(Dirac::Matrix &dMatrix, Tensor const &A, Tensor const &B)
  {
    Dirac::Matrix rrA;
    Dirac::Matrix rgA;
    Dirac::Matrix rbA;
    Dirac::Matrix grA;
    Dirac::Matrix gbA;
    Dirac::Matrix ggA;
    Dirac::Matrix brA;
    Dirac::Matrix bbA;
    Dirac::Matrix bgA;

    Dirac::Matrix rrB;
    Dirac::Matrix rgB;
    Dirac::Matrix rbB;
    Dirac::Matrix grB;
    Dirac::Matrix gbB;
    Dirac::Matrix ggB;
    Dirac::Matrix brB;
    Dirac::Matrix bbB;
    Dirac::Matrix bgB;

    A.getDiracMatrix(rrA, Base::col_RED,   Base::col_RED);
    A.getDiracMatrix(rgA, Base::col_RED,   Base::col_GREEN);
    A.getDiracMatrix(rbA, Base::col_RED,   Base::col_BLUE);
    A.getDiracMatrix(grA, Base::col_GREEN, Base::col_RED);
    A.getDiracMatrix(gbA, Base::col_GREEN, Base::col_BLUE);
    A.getDiracMatrix(ggA, Base::col_GREEN, Base::col_GREEN);
    A.getDiracMatrix(brA, Base::col_BLUE,  Base::col_RED);
    A.getDiracMatrix(bbA, Base::col_BLUE,  Base::col_BLUE);
    A.getDiracMatrix(bgA, Base::col_BLUE,  Base::col_GREEN);

    B.getDiracMatrix(rrB, Base::col_RED,   Base::col_RED);
    B.getDiracMatrix(rgB, Base::col_GREEN, Base::col_RED);
    B.getDiracMatrix(rbB, Base::col_BLUE,  Base::col_RED);
    B.getDiracMatrix(grB, Base::col_RED,   Base::col_GREEN);
    B.getDiracMatrix(gbB, Base::col_BLUE,  Base::col_GREEN);
    B.getDiracMatrix(ggB, Base::col_GREEN, Base::col_GREEN);
    B.getDiracMatrix(brB, Base::col_RED,   Base::col_BLUE);
    B.getDiracMatrix(bbB, Base::col_BLUE,  Base::col_BLUE);
    B.getDiracMatrix(bgB, Base::col_GREEN, Base::col_BLUE);

    rrA *= rrB;
    rgA *= rgB;
    rbA *= rbB;
    grA *= grB;
    gbA *= gbB;
    ggA *= ggB;
    brA *= brB;
    bbA *= bbB;
    bgA *= bgB;

    rrA += rgA;
    rrA += rbA;
    rrA += grA;
    rrA += gbA;
    rrA += ggA;
    rrA += brA;
    rrA += bbA;
    rrA += bgA;

    std::copy(&(rrA[0]), &(rrA[0]) + 16, &(dMatrix[0]));
  }

  /*  For a white source propagator we can use a faster constructor
      since we know which entries of the tensors are zero.
      This constructor is in particular used for of Dirac-diluted
      stochastic propagators, and therefore important in appication
      of the one-end-trick.
  */
  inline void getDiracMatrix(Dirac::Matrix &dMatrix, Tensor const &A, QCD::Tensor const &B, bool const colourDilutedSource)
  {
    if (!colourDilutedSource)
    {
      // note that "RED" as the "source" index actually addresses the only non-zero entries
      Dirac::Matrix xrA;
      Dirac::Matrix xgA;
      Dirac::Matrix xbA;
      Dirac::Matrix xrB;
      Dirac::Matrix xgB;
      Dirac::Matrix xbB;

      A.getDiracMatrix(xrA, Base::col_RED,   Base::col_RED);
      A.getDiracMatrix(xgA, Base::col_RED,   Base::col_GREEN);
      A.getDiracMatrix(xbA, Base::col_RED,   Base::col_BLUE);

      B.getDiracMatrix(xrB, Base::col_RED,   Base::col_RED);
      B.getDiracMatrix(xgB, Base::col_GREEN, Base::col_RED);
      B.getDiracMatrix(xbB, Base::col_BLUE,  Base::col_RED);

      // note that second QCD::Tensor is supposed to appear as a
      // hermitian conjugate one, so source and sink indices are swapped
      xrA *= xrB;
      xgA *= xgB;
      xbA *= xbB;

      xrA += xgA;
      xrA += xbA;
      std::copy(&(xrA[0]), &(xrA[0]) + 16, &(dMatrix[0]));
    }
    else if (colourDilutedSource)
      getDiracMatrix(dMatrix, A, B);
  }


  /*
      this is the underlying routine for a baryon contraction
  */
  inline void getDiracMatrix(Dirac::Matrix &dMatrix, Tensor const &A, Tensor const &B, Tensor const &C, Base::BaryonInterpolatingField const iPol)
  {
    // pre-contraction using interpolating field
    Dirac::Matrix result(std::complex< double >(0, 0));

    Tensor B_(B);

    switch(iPol)
    {
      case Base::bar_PROTON:
        B_.left_multiply_proton();
        B_.right_multiply_proton();
        B_.transposeFull();
      break;
      default:
      std::cerr << "unknown interpolating field in Matrix::Matrix(3 x QCD::Tensor, Base::BaryonInterpolatingField)!"
                << std::endl;
      std::cerr << "Aborting..." << std::endl;
      exit(1);
    }

    // For each of the nine colour combinations for QCD::Tensor A there are only
    // four combinations of colour for the other tensors B and C
    // that yield a non-zero epsilon.
    // Those are, in terms of the Matrixs:
    //  +(rrA, ggB, bbC), -(rrA, gbB, bgC), -(rrA, bgB, gbC), +(rrA, bbB, ggC)
    //  -(rgA, grB, bbC), +(rgA, gbB, brC), +(rgA, brB, gbC), -(rgA, bbB, grC)
    //  +(rbA, grB, bgC), -(rbA, ggB, brC), -(rbA, brB, ggC), +(rbA, bgB, grC)
    //  ---
    //  +(grA, bgB, rbC), -(grA, bbB, rgC), -(grA, rgB, bbC), +(grA, rbB, bgC)
    //  +(ggA, bbB, rrC), -(ggA, brB, rbC), -(ggA, rbB, brC), +(ggA, rrB, bbC)
    //  -(gbA, bgB, rrC), +(gbA, brB, rgC), +(gbA, rgB, brC), -(gbA, rrB, bgC)
    //  ---
    //  +(brA, rgB, gbC), -(brA, rbB, ggC), -(brA, ggB, rbC), +(brA, gbB, rgC)
    //  +(bgA, rbB, grC), -(bgA, rrB, gbC), -(bgA, gbB, rrC), +(bgA, grB, rbC)
    //  -(bbA, rgB, grC), +(bbA, rrB, ggC), +(bbA, ggB, rrC), -(bbA, grB, rgC)

    Dirac::Matrix rrA; 
    Dirac::Matrix rgA;
    Dirac::Matrix rbA;
    Dirac::Matrix grA;
    Dirac::Matrix ggA;
    Dirac::Matrix gbA;
    Dirac::Matrix brA;
    Dirac::Matrix bgA;
    Dirac::Matrix bbA;

    Dirac::Matrix rrB;
    Dirac::Matrix rgB;
    Dirac::Matrix rbB;
    Dirac::Matrix grB;
    Dirac::Matrix ggB;
    Dirac::Matrix gbB;
    Dirac::Matrix brB;
    Dirac::Matrix bgB;
    Dirac::Matrix bbB;

    Dirac::Matrix rrC;
    Dirac::Matrix rgC;
    Dirac::Matrix rbC;
    Dirac::Matrix grC;
    Dirac::Matrix ggC;
    Dirac::Matrix gbC;
    Dirac::Matrix brC;
    Dirac::Matrix bgC;
    Dirac::Matrix bbC;

    A.getDiracMatrix(rrA, Base::col_RED,   Base::col_RED);
    A.getDiracMatrix(rgA, Base::col_RED,   Base::col_GREEN);
    A.getDiracMatrix(rbA, Base::col_RED,   Base::col_BLUE);
    A.getDiracMatrix(grA, Base::col_GREEN, Base::col_RED);
    A.getDiracMatrix(ggA, Base::col_GREEN, Base::col_GREEN);
    A.getDiracMatrix(gbA, Base::col_GREEN, Base::col_BLUE);
    A.getDiracMatrix(brA, Base::col_BLUE,  Base::col_RED);
    A.getDiracMatrix(bgA, Base::col_BLUE,  Base::col_GREEN);
    A.getDiracMatrix(bbA, Base::col_BLUE,  Base::col_BLUE);

    // the source and sink colours are interchanged due to transposing
    B_.getDiracMatrix(rrB, Base::col_RED,   Base::col_RED);
    B_.getDiracMatrix(rgB, Base::col_GREEN, Base::col_RED);
    B_.getDiracMatrix(rbB, Base::col_BLUE,  Base::col_RED);
    B_.getDiracMatrix(grB, Base::col_RED,   Base::col_GREEN);
    B_.getDiracMatrix(ggB, Base::col_GREEN, Base::col_GREEN);
    B_.getDiracMatrix(gbB, Base::col_BLUE,  Base::col_GREEN);
    B_.getDiracMatrix(brB, Base::col_RED,   Base::col_BLUE);
    B_.getDiracMatrix(bgB, Base::col_GREEN, Base::col_BLUE);
    B_.getDiracMatrix(bbB, Base::col_BLUE,  Base::col_BLUE);

    C.getDiracMatrix(rrC, Base::col_RED,   Base::col_RED);
    C.getDiracMatrix(rgC, Base::col_RED,   Base::col_GREEN);
    C.getDiracMatrix(rbC, Base::col_RED,   Base::col_BLUE);
    C.getDiracMatrix(grC, Base::col_GREEN, Base::col_RED);
    C.getDiracMatrix(ggC, Base::col_GREEN, Base::col_GREEN);
    C.getDiracMatrix(gbC, Base::col_GREEN, Base::col_BLUE);
    C.getDiracMatrix(brC, Base::col_BLUE,  Base::col_RED);
    C.getDiracMatrix(bgC, Base::col_BLUE,  Base::col_GREEN);
    C.getDiracMatrix(bbC, Base::col_BLUE,  Base::col_BLUE);

    result += rrC*(ggB*bbA);
    result -= rrC*(gbB*bgA);
    result -= rrC*(bgB*gbA);
    result += rrC*(bbB*ggA);
    //  ---
    result -= rgC*(grB*bbA);
    result += rgC*(gbB*brA);
    result += rgC*(brB*gbA);
    result -= rgC*(bbB*grA);
    //  ---
    result += rbC*(grB*bgA);
    result -= rbC*(ggB*brA);
    result -= rbC*(brB*ggA);
    result += rbC*(bgB*grA);
    //  --- ---  ---
    result += grC*(bgB*rbA);
    result -= grC*(bbB*rgA);
    result -= grC*(rgB*bbA);
    result += grC*(rbB*bgA);
    //  ---
    result += ggC*(bbB*rrA);
    result -= ggC*(brB*rbA);
    result -= ggC*(rbB*brA);
    result += ggC*(rrB*bbA);
    //  ---
    result -= gbC*(bgB*rrA);
    result += gbC*(brB*rgA);
    result += gbC*(rgB*brA);
    result -= gbC*(rrB*bgA);
    //  --- ---  ---
    result += brC*(rgB*gbA);
    result -= brC*(rbB*ggA);
    result -= brC*(ggB*rbA);
    result += brC*(gbB*rgA);
    //  ---
    result += bgC*(rbB*grA);
    result -= bgC*(rrB*gbA);
    result -= bgC*(gbB*rrA);
    result += bgC*(grB*rbA);
    //  ---
    result -= bbC*(rgB*grA);
    result += bbC*(rrB*ggA);
    result += bbC*(ggB*rrA);
    result -= bbC*(grB*rgA);

    switch(iPol)
    {
      case Base::bar_PROTON:

        result += rrA*((ggB*bbC).trace());
        result -= rrA*((gbB*bgC).trace());
        result -= rrA*((bgB*gbC).trace());
        result += rrA*((bbB*ggC).trace());
        //  ---
        result -= rgA*((grB*bbC).trace());
        result += rgA*((gbB*brC).trace());
        result += rgA*((brB*gbC).trace());
        result -= rgA*((bbB*grC).trace());
        //  ---
        result += rbA*((grB*bgC).trace());
        result -= rbA*((ggB*brC).trace());
        result -= rbA*((brB*ggC).trace());
        result += rbA*((bgB*grC).trace());
        //  --- --- ---
        result += grA*((bgB*rbC).trace());
        result -= grA*((bbB*rgC).trace());
        result -= grA*((rgB*bbC).trace());
        result += grA*((rbB*bgC).trace());
        //  ---
        result += ggA*((bbB*rrC).trace());
        result -= ggA*((brB*rbC).trace());
        result -= ggA*((rbB*brC).trace());
        result += ggA*((rrB*bbC).trace());
        //  ---
        result -= gbA*((bgB*rrC).trace());
        result += gbA*((brB*rgC).trace());
        result += gbA*((rgB*brC).trace());
        result -= gbA*((rrB*bgC).trace());
        //  --- --- ---
        result += brA*((rgB*gbC).trace());
        result -= brA*((rbB*ggC).trace());
        result -= brA*((ggB*rbC).trace());
        result += brA*((gbB*rgC).trace());
        //  ---
        result += bgA*((rbB*grC).trace());
        result -= bgA*((rrB*gbC).trace());
        result -= bgA*((gbB*rrC).trace());
        result += bgA*((grB*rbC).trace());
        //  ---
        result -= bbA*((rgB*grC).trace());
        result += bbA*((rrB*ggC).trace());
        result += bbA*((ggB*rrC).trace());
        result -= bbA*((grB*rgC).trace());

      break;
    }
//     std::cout << result << std::endl;
//     std::cout << "trace: " << result.trace() << std::endl;
    std::copy(&(result[0]), &(result[0]) + 16, &(dMatrix[0]));
  }

}
