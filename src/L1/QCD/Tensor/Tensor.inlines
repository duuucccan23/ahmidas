namespace QCD
{
  template< size_t L, size_t T >
  inline Tensor< L, T >::Tensor(Core::Grid< L, T > &grid)
  {
    for (Core::Field< Spinor, L, T > **iter = d_components; iter != d_components + 12; ++iter)
      *iter = new Core::Field< Spinor, L, T >(grid);
  }

  template< size_t L, size_t T >
  inline Tensor< L, T >::Tensor(Tensor< L, T > const &other)
  {
    for (size_t ctr = 0; ctr < 12; ++ctr)
      d_components[ctr] = new Core::Field< Spinor, L, T >(other.d_components[ctr]);
  }

  template< size_t L, size_t T >
  inline Tensor< L, T >::Tensor(Core::Field< Spinor, L, T > *data)
  {
    // NOTE We assume control over the array of fields -- would be nice to signal this somehow.
    std::copy(data, data + 12, d_components);
  }

  template< size_t L, size_t T >
  inline Tensor< L, T >::~Tensor()
  {
    for (Core::Field< Spinor, L, T > **iter = d_components; iter != d_components + 12; ++iter)
      delete(*iter);
  }

  template< size_t L, size_t T >
  inline typename Tensor< L, T >::iterator_full Tensor< L, T >::begin()
  {
    return iterator_full(d_components, 1);
  }

  template< size_t L, size_t T >
  inline typename Tensor< L, T >::iterator_full Tensor< L, T >::end()
  {
    return iterator_full(d_components + 12, 1);
  }

  template< size_t L, size_t T >
  inline typename Tensor< L, T >::const_iterator_full Tensor< L, T >::begin() const
  {
    return const_iterator_full(d_components, 1);
  }

  template< size_t L, size_t T >
  inline typename Tensor< L, T >::const_iterator_full Tensor< L, T >::end() const
  {
    return const_iterator_full(d_components + 12, 1);
  }

  template< size_t L, size_t T >
  inline typename Tensor< L, T >::iterator_colour Tensor< L, T >::begin(Core::ColourIndex const index)
  {
    return iterator_colour(d_components + index, 4);
  }

  template< size_t L, size_t T >
  inline typename Tensor< L, T >::iterator_colour Tensor< L, T >::end(Core::ColourIndex const index)
  {
    return iterator_colour(d_components + index + 12, 4);
  }

  template< size_t L, size_t T >
  inline typename Tensor< L, T >::const_iterator_colour Tensor< L, T >::begin(Core::ColourIndex const index) const
  {
    return const_iterator_colour(d_components + index, 4);
  }

  template< size_t L, size_t T >
  inline typename Tensor< L, T >::const_iterator_colour Tensor< L, T >::end(Core::ColourIndex const index) const
  {
    return const_iterator_colour(d_components + index + 12, 4);
  }

  template< size_t L, size_t T >
  inline typename Tensor< L, T >::iterator_dirac Tensor< L, T >::begin(Core::DiracIndex const index)
  {
    return iterator_dirac(d_components + 4 * index, 1);
  }

  template< size_t L, size_t T >
  inline typename Tensor< L, T >::iterator_dirac Tensor< L, T >::end(Core::DiracIndex const index)
  {
    return iterator_dirac(d_components + 4 * (index + 1), 1);
  }

  template< size_t L, size_t T >
  inline typename Tensor< L, T >::const_iterator_dirac Tensor< L, T >::begin(Core::DiracIndex const index) const
  {
    return const_iterator_dirac(d_components + 4 * index, 1);
  }

  template< size_t L, size_t T >
  inline typename Tensor< L, T >::const_iterator_dirac Tensor< L, T >::end(Core::DiracIndex const index) const
  {
    return const_iterator_dirac(d_components + 4 * (index + 1), 1);
  }
}
