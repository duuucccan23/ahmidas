namespace Core
{
  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline Propagator< L, T, Dirac, Colour >::Propagator()
    : d_references(new size_t(1)), d_components(new Field< std::complex< double >, L, T > [(size_t)std::pow(4,Dirac)*(size_t)std::pow(3,Colour)])
  {
    getStrides();
  }
  
  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline Propagator< L, T, Dirac, Colour >::Propagator(Propagator< L, T, Dirac, Colour > const &other)
    : d_components(other.d_components)
  {
    *d_references += 1;
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline Propagator< L, T, Dirac, Colour >::~Propagator()
  {
    destroy();
  }
  
  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline void Propagator< L, T, Dirac, Colour >::getStrides()
  {
    if (Colour > 0)
    {
      colour_strides = new size_t[Colour];
      for (size_t idx = 0; idx<Colour; ++idx)
        colour_strides[idx] = (size_t)pow(3, Colour-idx) * (size_t)pow(4, Dirac > idx ? Dirac-idx : 0);
    }
    else 
      colour_strides = 0;
    if (Dirac > 0)
    {
      dirac_strides = new size_t[Dirac];
      for (size_t idx = 0; idx<Dirac; ++idx)
        dirac_strides[idx] = (size_t)pow(3, Colour-idx < 0 ? 0 : Colour-idx+1) * (size_t)pow(4, Dirac-idx-1);
    }
    else 
      dirac_strides = 0;
  }
  
//   template< size_t L, size_t T, size_t Dirac, size_t Colour >
//   inline Core::Field< QCD::Spinor, L, T > &Propagator< L, T, Dirac, Colour >::operator[](size_t const idx)
//   {
//     isolate();
//     return *(d_components[idx]);
//   }
// 
//   template< size_t L, size_t T, size_t Dirac, size_t Colour >
//   inline Core::Field< QCD::Spinor, L, T > const &Propagator< L, T, Dirac, Colour >::operator[](size_t const idx) const
//   {
//     return *(d_components[idx]);
//   }
  
  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline typename Propagator< L, T, Dirac, Colour >::iterator_full Propagator< L, T, Dirac, Colour >::begin()
  {
    isolate();
    return iterator_full();
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline typename Propagator< L, T, Dirac, Colour >::iterator_full Propagator< L, T, Dirac, Colour >::end()
  {
    isolate();
    return iterator_full();
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline typename Propagator< L, T, Dirac, Colour >::const_iterator_full Propagator< L, T, Dirac, Colour >::begin() const
  {
    return const_iterator_full(d_components);
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline typename Propagator< L, T, Dirac, Colour >::const_iterator_full Propagator< L, T, Dirac, Colour >::end() const
  {
    return const_iterator_full(d_components + 12);
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline typename Propagator< L, T, Dirac, Colour >::iterator_colour Propagator< L, T, Dirac, Colour >::begin(Base::ColourIndex const index)
  {
    isolate();
    return iterator_colour(d_components + index);
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline typename Propagator< L, T, Dirac, Colour >::iterator_colour Propagator< L, T, Dirac, Colour >::end(Base::ColourIndex const index)
  {
    isolate();
    return iterator_colour(d_components + index + 12);
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline typename Propagator< L, T, Dirac, Colour >::const_iterator_colour Propagator< L, T, Dirac, Colour >::begin(Base::ColourIndex const index) const
  {
    return const_iterator_colour(d_components + index);
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline typename Propagator< L, T, Dirac, Colour >::const_iterator_colour Propagator< L, T, Dirac, Colour >::end(Base::ColourIndex const index) const
  {
    return const_iterator_colour(d_components + index + 12);
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline typename Propagator< L, T, Dirac, Colour >::iterator_dirac Propagator< L, T, Dirac, Colour >::begin(Base::DiracIndex const index)
  {
    isolate();
    return iterator_dirac(d_components + 3 * index);
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline typename Propagator< L, T, Dirac, Colour >::iterator_dirac Propagator< L, T, Dirac, Colour >::end(Base::DiracIndex const index)
  {
    isolate();
    return iterator_dirac(d_components + 3 * (index + 1));
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline typename Propagator< L, T, Dirac, Colour >::const_iterator_dirac Propagator< L, T, Dirac, Colour >::begin(Base::DiracIndex const index) const
  {
    return const_iterator_dirac(d_components + 3 * index);
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline typename Propagator< L, T, Dirac, Colour >::const_iterator_dirac Propagator< L, T, Dirac, Colour >::end(Base::DiracIndex const index) const
  {
    return const_iterator_dirac(d_components + 3 * (index + 1));
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline size_t Propagator< L, T, Dirac, Colour >::size() const
  {
    return (size_t)std::pow(4,Dirac)*(size_t)std::pow(3,Colour);
  }



  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline Propagator< L, T, Dirac-1, Colour > &Propagator< L, T, Dirac, Colour >::getDirac(Base::DiracIndex const dirIdx,
                                                                                          size_t const DiracID)
  {
    assert(Dirac>0);
    isolate();
    size_t stride = dirac_stride[DiracID];
    size_t offset = dirIdx*dirac_stride[DiracID];
    Propagator< L, T, Dirac-1, Colour > tmp_prop;
    // NOTE this has to be done more efficiently, need new constructor that leaves d_components empty
    // what if Propagator< L, T, Dirac, Colour > is deleted?!
    delete [] d_components;
    // check again carefully - I think this is not working well for Dirac > 2
    for (size_t idx=0; idx<tmp_prop.size(); idx++)
      tmp_prop.d_components[idx] = d_components[idx%stride+4*idx/stride+offset];
    return tmp_prop;
  }  
  
  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline Propagator< L, T, Dirac-1, Colour > const &Propagator< L, T, Dirac, Colour >::getDirac(Base::DiracIndex const dirIdx,
                                                                                                size_t const DiracID)
  {
    assert(Dirac>0);
    size_t stride = dirac_stride[DiracID];
    size_t offset = dirIdx*dirac_stride[DiracID];
    Propagator< L, T, Dirac-1, Colour > tmp_prop;
    delete [] d_components;
    for (size_t idx=0; idx<tmp_prop.size(); idx++)
      tmp_prop.d_components[idx] = d_components[idx%stride+4*idx/stride+offset];
    return tmp_prop;
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline Propagator< L, T, Dirac, Colour-1 > &Propagator< L, T, Dirac, Colour >::getColour(Base::ColourIndex const dirIdx,
                                                                                           const size_t ColourID)
  {
    isolate();
    assert(Colour>0);
    size_t stride = colour_stride[ColourID];
    size_t offset = dirIdx*dirac_stride[DiracID];
    Propagator< L, T, Dirac-1, Colour > tmp_prop;
    delete [] d_components;
    for (size_t idx=0; idx<tmp_prop.size(); idx++)
      tmp_prop.d_components[idx] = d_components[idx%stride+3*idx/stride+offset];
    return tmp_prop;
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline Propagator< L, T, Dirac, Colour-1 > const &Propagator< L, T, Dirac, Colour >::getColour(Base::ColourIndex const dirIdx,
                                                                                                 const size_t ColourID)
  {
    isolate();
    assert(Colour>0);
    size_t stride = colour_stride[ColourID];
    size_t offset = dirIdx*dirac_stride[DiracID];
    Propagator< L, T, Dirac-1, Colour > tmp_prop;
    delete [] d_components;
    for (size_t idx=0; idx<tmp_prop.size(); idx++)
      tmp_prop.d_components[idx] = d_components[idx%stride+3*idx/stride+offset];
    return tmp_prop;
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline Propagator< L, T, Dirac-1, Color-1 > &Propagator< L, T, Dirac, Colour >::operator()(Base::ColourIndex const colIdx,
                                                                                             Base::DiracIndex const dirIdx,
                                                                                             const size_t ColorID,
                                                                                             const size_t DiracID)
  {
    isolate();
    getDirac(dirIdx, DiracID).getColour(colIdx);
    return d_components[colIdx + 3 * dirIdx];
  }

  template< size_t L, size_t T, size_t Dirac, size_t Colour >
  inline Core::Field< QCD::Spinor, L, T > const &Propagator< L, T, Dirac, Colour >::operator()(Base::ColourIndex const colIdx,
                                                                                              Base::DiracIndex const dirIdx,
                                                                                              const size_t ColorID,
                                                                                              const size_t DiracID)
  {
    return d_components[colIdx + 3 * dirIdx];
  }
  
}
