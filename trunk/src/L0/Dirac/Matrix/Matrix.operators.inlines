namespace Dirac
{

 inline Matrix Matrix::operator+(Matrix const &other) const
  {
    Matrix tmp;
    std::transform(d_data, d_data+16, other.d_data, tmp.d_data,
                   std::plus< std::complex< double > >());
    return tmp;
  }

  inline Matrix Matrix::operator-(Matrix const &other) const
  {
    Matrix tmp;
    std::transform(d_data, d_data+16, other.d_data, tmp.d_data,
                   std::minus< std::complex< double > >());
    return tmp;
  }

  inline void Matrix::operator+=(Matrix const &other)
  {
    std::transform(d_data, d_data+16, other.d_data, d_data,
                   std::plus< std::complex< double > >());
  }

  inline void Matrix::operator-=(Matrix const &other)
  {
    std::transform(d_data, d_data+16, other.d_data, d_data,
                   std::minus< std::complex< double > >());
  }

//   inline Matrix &Matrix::operator=(Matrix const &rhs)
//   {
//     if (this != &rhs)
//       std::copy(rhs.d_data, rhs.d_data + 16, d_data);
//     return *this;
//   }

  inline void Matrix::operator*=(Matrix const &rhs)
  {
    Matrix tmpR(rhs);
    Matrix tmpL(*this);
    std::complex< double > zero(0, 0);
    //transpose in order to use inner_product of ranges
    std::swap(tmpR.d_data[ 1], tmpR.d_data[ 4]);
    std::swap(tmpR.d_data[ 2], tmpR.d_data[ 8]);
    std::swap(tmpR.d_data[ 3], tmpR.d_data[12]);
    std::swap(tmpR.d_data[ 6], tmpR.d_data[ 9]);
    std::swap(tmpR.d_data[ 7], tmpR.d_data[13]);
    std::swap(tmpR.d_data[11], tmpR.d_data[14]);
    d_data[ 0] = std::inner_product(tmpL.d_data     , tmpL.d_data +  4, tmpR.d_data,      zero);
    d_data[ 1] = std::inner_product(tmpL.d_data     , tmpL.d_data +  4, tmpR.d_data +  4, zero);
    d_data[ 2] = std::inner_product(tmpL.d_data     , tmpL.d_data +  4, tmpR.d_data +  8, zero);
    d_data[ 3] = std::inner_product(tmpL.d_data     , tmpL.d_data +  4, tmpR.d_data + 12, zero);
    d_data[ 4] = std::inner_product(tmpL.d_data +  4, tmpL.d_data +  8, tmpR.d_data,      zero);
    d_data[ 5] = std::inner_product(tmpL.d_data +  4, tmpL.d_data +  8, tmpR.d_data +  4, zero);
    d_data[ 6] = std::inner_product(tmpL.d_data +  4, tmpL.d_data +  8, tmpR.d_data +  8, zero);
    d_data[ 7] = std::inner_product(tmpL.d_data +  4, tmpL.d_data +  8, tmpR.d_data + 12, zero);
    d_data[ 8] = std::inner_product(tmpL.d_data +  8, tmpL.d_data + 12, tmpR.d_data,      zero);
    d_data[ 9] = std::inner_product(tmpL.d_data +  8, tmpL.d_data + 12, tmpR.d_data +  4, zero);
    d_data[10] = std::inner_product(tmpL.d_data +  8, tmpL.d_data + 12, tmpR.d_data +  8, zero);
    d_data[11] = std::inner_product(tmpL.d_data +  8, tmpL.d_data + 12, tmpR.d_data + 12, zero);
    d_data[12] = std::inner_product(tmpL.d_data + 12, tmpL.d_data + 16, tmpR.d_data,      zero);
    d_data[13] = std::inner_product(tmpL.d_data + 12, tmpL.d_data + 16, tmpR.d_data +  4, zero);
    d_data[14] = std::inner_product(tmpL.d_data + 12, tmpL.d_data + 16, tmpR.d_data +  8, zero);
    d_data[15] = std::inner_product(tmpL.d_data + 12, tmpL.d_data + 16, tmpR.d_data + 12, zero);
  }

  inline Matrix Matrix::operator*(Matrix const &rhs) const
  {
    Matrix tmp(*this);
    tmp *= rhs;
    return tmp;
  }

  inline Matrix Matrix::operator*(double const &factor) const
  {
    Matrix tmp(*this);
    tmp *= factor;
    return tmp;
  }

  inline Matrix Matrix::operator*(std::complex< double > const &factor) const
  {
    Matrix tmp(*this);
    tmp *= factor;
    return tmp;
  }

  inline void Matrix::operator*=(double const &factor)
  {
    std::transform(reinterpret_cast< double * > (d_data),
                   reinterpret_cast< double * > (d_data+16),
                   reinterpret_cast< double * > (d_data),
                   bind2nd(std::multiplies< double >(), factor));
  }

  inline void Matrix::operator*=(std::complex< double > const &factor)
  {
    std::transform(d_data, d_data+16, d_data,
                   bind2nd(std::multiplies< std::complex< double > >(), factor));
  }

  inline std::complex< double > const &Matrix::operator()(Base::DiracIndex const Dirac_src,
                                                                 Base::DiracIndex const Dirac_snk) const
  {
    return d_data[Dirac_src + 4*Dirac_snk];
  }

  inline std::ostream &operator<<(std::ostream &out, Matrix const &mat)
  {
    out << std::scientific << std::setprecision(3) << std::showpos
        << "[ " << mat.d_data[ 0].real() << "  " << mat.d_data[ 0].imag() << " * i   "
                << mat.d_data[ 1].real() << "  " << mat.d_data[ 1].imag() << " * i   "
                << mat.d_data[ 2].real() << "  " << mat.d_data[ 2].imag() << " * i   "
                << mat.d_data[ 3].real() << "  " << mat.d_data[ 3].imag() << " * i  ]"
                << std::endl
        << "[ " << mat.d_data[ 4].real() << "  " << mat.d_data[ 4].imag() << " * i   "
                << mat.d_data[ 5].real() << "  " << mat.d_data[ 5].imag() << " * i   "
                << mat.d_data[ 6].real() << "  " << mat.d_data[ 6].imag() << " * i   "
                << mat.d_data[ 7].real() << "  " << mat.d_data[ 7].imag() << " * i  ]"
                << std::endl
        << "[ " << mat.d_data[ 8].real() << "  " << mat.d_data[ 8].imag() << " * i   "
                << mat.d_data[ 9].real() << "  " << mat.d_data[ 9].imag() << " * i   "
                << mat.d_data[10].real() << "  " << mat.d_data[10].imag() << " * i   "
                << mat.d_data[11].real() << "  " << mat.d_data[11].imag() << " * i  ]"
                << std::endl
        << "[ " << mat.d_data[12].real() << "  " << mat.d_data[12].imag() << " * i   "
                << mat.d_data[13].real() << "  " << mat.d_data[13].imag() << " * i   "
                << mat.d_data[14].real() << "  " << mat.d_data[14].imag() << " * i   "
                << mat.d_data[15].real() << "  " << mat.d_data[15].imag() << " * i  ]"
                << std::endl;
    return out;
  }

}
