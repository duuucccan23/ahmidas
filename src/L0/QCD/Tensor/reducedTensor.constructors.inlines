#include "Tensor_multiply_interpolating_field.inlines"

namespace QCD
{

  // private constructor
  inline reducedTensor::reducedTensor(Tensor const &fullTensor, Base::ColourIndex const colour_src, Base::ColourIndex const colour_snk)
  {
    size_t index = 12*colour_src + colour_snk;
    d_data[ 0] = fullTensor.d_data[index     ];
    d_data[ 1] = fullTensor.d_data[index +   3];
    d_data[ 2] = fullTensor.d_data[index +   6];
    d_data[ 3] = fullTensor.d_data[index +   9];
    d_data[ 4] = fullTensor.d_data[index +  36];
    d_data[ 5] = fullTensor.d_data[index +  39];
    d_data[ 6] = fullTensor.d_data[index +  42];
    d_data[ 7] = fullTensor.d_data[index +  45];
    d_data[ 8] = fullTensor.d_data[index +  72];
    d_data[ 9] = fullTensor.d_data[index +  75];
    d_data[10] = fullTensor.d_data[index +  78];
    d_data[11] = fullTensor.d_data[index +  81];
    d_data[12] = fullTensor.d_data[index + 108];
    d_data[13] = fullTensor.d_data[index + 111];
    d_data[14] = fullTensor.d_data[index + 114];
    d_data[15] = fullTensor.d_data[index + 117];
  }

  inline reducedTensor::reducedTensor()
  {
    //std::fill(d_data, d_data + 16, std::complex< double >(0.0, 0.0));
  }

  inline reducedTensor::reducedTensor(std::complex< double > const& value)
  {
    std::fill_n(d_data, 16, value);
  }


  inline reducedTensor::reducedTensor(reducedTensor const &other)
  {
    std::copy(other.d_data, other.d_data + 16, d_data);
  }


  /* the following constructors are used to perform contractions */

  inline reducedTensor::reducedTensor(Tensor const &A, Tensor const &B)
  {

    reducedTensor rr(A, Base::col_RED,   Base::col_RED);
    reducedTensor rg(A, Base::col_RED,   Base::col_GREEN);
    //std::cout << "rg = \n" << rg << std::endl;
    reducedTensor rb(A, Base::col_RED,   Base::col_BLUE);
    reducedTensor gr(A, Base::col_GREEN, Base::col_RED);
    //std::cout << "gr = \n" << gr << std::endl;
    //exit(1);
    reducedTensor gb(A, Base::col_GREEN, Base::col_BLUE);
    reducedTensor gg(A, Base::col_GREEN, Base::col_GREEN);
    reducedTensor br(A, Base::col_BLUE,  Base::col_RED);
    reducedTensor bb(A, Base::col_BLUE,  Base::col_BLUE);
    reducedTensor bg(A, Base::col_BLUE,  Base::col_GREEN);

    rr *= reducedTensor(B, Base::col_RED,   Base::col_RED);
    rg *= reducedTensor(B, Base::col_GREEN, Base::col_RED);
    rb *= reducedTensor(B, Base::col_BLUE,  Base::col_RED);
    gr *= reducedTensor(B, Base::col_RED,   Base::col_GREEN);
    gb *= reducedTensor(B, Base::col_BLUE,  Base::col_GREEN);
    gg *= reducedTensor(B, Base::col_GREEN, Base::col_GREEN);
    br *= reducedTensor(B, Base::col_RED,   Base::col_BLUE);
    bb *= reducedTensor(B, Base::col_BLUE,  Base::col_BLUE);
    bg *= reducedTensor(B, Base::col_GREEN, Base::col_BLUE);

    rr += rg;
    rr += rb;
    rr += gr;
    rr += gb;
    rr += gg;
    rr += br;
    rr += bb;
    rr += bg;

    std::copy(rr.d_data, rr.d_data + 16, d_data);
  }

  /*  For a white source propagator we can use a faster constructor
      since we know which entries of the tensors are zero.
      This constructor is in particular used for of Dirac-diluted
      stochastic propagators, and therefore important in appication
      of the one-end-trick.
  */
  inline reducedTensor::reducedTensor(Tensor const &A, Tensor const &B, bool const colourDilutedSource)
  {
    if (!colourDilutedSource)
    {
      // note that "RED" as the "source" index actually addresses the only non-zero entries
      reducedTensor xr(A, Base::col_RED,   Base::col_RED);
      reducedTensor xg(A, Base::col_RED,   Base::col_GREEN);
      reducedTensor xb(A, Base::col_RED,   Base::col_BLUE);

      // note that second Tensor is suppoed to appear as a
      // hermitian conjugate one, so source and sink indices are swapped
      xr *= reducedTensor(B, Base::col_RED,   Base::col_RED);
      xg *= reducedTensor(B, Base::col_GREEN, Base::col_RED);
      xb *= reducedTensor(B, Base::col_BLUE,  Base::col_RED);

      xr += xg;
      xr += xb;
      std::copy(xr.d_data, xr.d_data + 16, d_data);
    }
    else if (colourDilutedSource)
      *this = reducedTensor(A, B);
  }


  /*
      this is the underlying routine for a baryon contraction
  */
  inline reducedTensor::reducedTensor(Tensor const &A, Tensor const &B, Tensor const &C, Base::BaryonInterpolatingField const iPol)
  {
    // pre-contraction using interpolating field
    reducedTensor result(std::complex< double >(0, 0));

    Tensor B_(B);

    switch(iPol)
    {
      case Base::bar_PROTON:
        B_.left_multiply_proton();
        B_.right_multiply_proton();
        B_.transposeFull();
      break;
      default:
      std::cerr << "unknown interpolating field in reducedTensor::reducedTensor(3 x Tensor, Base::BaryonInterpolatingField)!"
                << std::endl;
      std::cerr << "Aborting..." << std::endl;
      exit(1);
    }

    // For each of the nine colour combinations for Tensor A there are only
    // four combinations of colour for the other tensors B and C
    // that yield a non-zero epsilon.
    // Those are, in terms of the reducedTensors:
    //  +(rrA, ggB, bbC), -(rrA, gbB, bgC), -(rrA, bgB, gbC), +(rrA, bbB, ggC)
    //  -(rgA, grB, bbC), +(rgA, gbB, brC), +(rgA, brB, gbC), -(rgA, bbB, grC)
    //  +(rbA, grB, bgC), -(rbA, ggB, brC), -(rbA, brB, ggC), +(rbA, bgB, grC)
    //  ---
    //  +(grA, bgB, rbC), -(grA, bbB, rgC), -(grA, rgB, bbC), +(grA, rbB, bgC)
    //  +(ggA, bbB, rrC), -(ggA, brB, rbC), -(ggA, rbB, brC), +(ggA, rrB, bbC)
    //  -(gbA, bgB, rrC), +(gbA, brB, rgC), +(gbA, rgB, brC), -(gbA, rrB, bgC)
    //  ---
    //  +(brA, rgB, gbC), -(brA, rbB, ggC), -(brA, ggB, rbC), +(brA, gbB, rgC)
    //  +(bgA, rbB, grC), -(bgA, rrB, gbC), -(bgA, gbB, rrC), +(bgA, grB, rbC)
    //  -(bbA, rgB, grC), +(bbA, rrB, ggC), +(bbA, ggB, rrC), -(bbA, grB, rgC)

    reducedTensor rrA(A, Base::col_RED,   Base::col_RED);
    reducedTensor rgA(A, Base::col_RED,   Base::col_GREEN);
    reducedTensor rbA(A, Base::col_RED,   Base::col_BLUE);
    reducedTensor grA(A, Base::col_GREEN, Base::col_RED);
    reducedTensor ggA(A, Base::col_GREEN, Base::col_GREEN);
    reducedTensor gbA(A, Base::col_GREEN, Base::col_BLUE);
    reducedTensor brA(A, Base::col_BLUE,  Base::col_RED);
    reducedTensor bgA(A, Base::col_BLUE,  Base::col_GREEN);
    reducedTensor bbA(A, Base::col_BLUE,  Base::col_BLUE);

//     reducedTensor rrB(B_, Base::col_RED,   Base::col_RED);
//     reducedTensor rgB(B_, Base::col_RED,   Base::col_GREEN);
//     reducedTensor rbB(B_, Base::col_RED,   Base::col_BLUE);
//     reducedTensor grB(B_, Base::col_GREEN, Base::col_RED);
//     reducedTensor gbB(B_, Base::col_GREEN, Base::col_BLUE);
//     reducedTensor ggB(B_, Base::col_GREEN, Base::col_GREEN);
//     reducedTensor brB(B_, Base::col_BLUE,  Base::col_RED);
//     reducedTensor bbB(B_, Base::col_BLUE,  Base::col_BLUE);
//     reducedTensor bgB(B_, Base::col_BLUE,  Base::col_GREEN);

    // the source and sink colours are interchanged due to transposing
    reducedTensor rrB(B_, Base::col_RED,   Base::col_RED);
    reducedTensor rgB(B_, Base::col_GREEN, Base::col_RED);
    reducedTensor rbB(B_, Base::col_BLUE,  Base::col_RED);
    reducedTensor grB(B_, Base::col_RED,   Base::col_GREEN);
    reducedTensor ggB(B_, Base::col_GREEN, Base::col_GREEN);
    reducedTensor gbB(B_, Base::col_BLUE,  Base::col_GREEN);
    reducedTensor brB(B_, Base::col_RED,   Base::col_BLUE);
    reducedTensor bgB(B_, Base::col_GREEN, Base::col_BLUE);
    reducedTensor bbB(B_, Base::col_BLUE,  Base::col_BLUE);

    reducedTensor rrC(C, Base::col_RED,   Base::col_RED);
    reducedTensor rgC(C, Base::col_RED,   Base::col_GREEN);
    reducedTensor rbC(C, Base::col_RED,   Base::col_BLUE);
    reducedTensor grC(C, Base::col_GREEN, Base::col_RED);
    reducedTensor ggC(C, Base::col_GREEN, Base::col_GREEN);
    reducedTensor gbC(C, Base::col_GREEN, Base::col_BLUE);
    reducedTensor brC(C, Base::col_BLUE,  Base::col_RED);
    reducedTensor bgC(C, Base::col_BLUE,  Base::col_GREEN);
    reducedTensor bbC(C, Base::col_BLUE,  Base::col_BLUE);

    result += rrA*(ggB*bbC);
    result -= rrA*(gbB*bgC);
    result -= rrA*(bgB*gbC);
    result += rrA*(bbB*ggC);
    //  ---
    result -= rgA*(grB*bbC);
    result += rgA*(gbB*brC);
    result += rgA*(brB*gbC);
    result -= rgA*(bbB*grC);
    //  ---
    result += rbA*(grB*bgC);
    result -= rbA*(ggB*brC);
    result -= rbA*(brB*ggC);
    result += rbA*(bgB*grC);
    //  --- --- ---
    result += grA*(bgB*rbC);
    result -= grA*(bbB*rgC);
    result -= grA*(rgB*bbC);
    result += grA*(rbB*bgC);
    //  ---
    result += ggA*(bbB*rrC);
    result -= ggA*(brB*rbC);
    result -= ggA*(rbB*brC);
    result += ggA*(rrB*bbC);
    //  ---
    result -= gbA*(bgB*rrC);
    result += gbA*(brB*rgC);
    result += gbA*(rgB*brC);
    result -= gbA*(rrB*bgC);
    //  --- --- ---
    result += brA*(rgB*gbC);
    result -= brA*(rbB*ggC);
    result -= brA*(ggB*rbC);
    result += brA*(gbB*rgC);
    //  ---
    result += bgA*(rbB*grC);
    result -= bgA*(rrB*gbC);
    result -= bgA*(gbB*rrC);
    result += bgA*(grB*rbC);
    //  ---
    result -= bbA*(rgB*grC);
    result += bbA*(rrB*ggC);
    result += bbA*(ggB*rrC);
    result -= bbA*(grB*rgC);

    //result *= -1.0;

    switch(iPol)
    {
      case Base::bar_PROTON:

        result += rrA*((ggB*bbC).trace());
        result -= rrA*((gbB*bgC).trace());
        result -= rrA*((bgB*gbC).trace());
        result += rrA*((bbB*ggC).trace());
        //  ---
        result -= rgA*((grB*bbC).trace());
        result += rgA*((gbB*brC).trace());
        result += rgA*((brB*gbC).trace());
        result -= rgA*((bbB*grC).trace());
        //  ---
        result += rbA*((grB*bgC).trace());
        result -= rbA*((ggB*brC).trace());
        result -= rbA*((brB*ggC).trace());
        result += rbA*((bgB*grC).trace());
        //  --- --- ---
        result += grA*((bgB*rbC).trace());
        result -= grA*((bbB*rgC).trace());
        result -= grA*((rgB*bbC).trace());
        result += grA*((rbB*bgC).trace());
        //  ---
        result += ggA*((bbB*rrC).trace());
        result -= ggA*((brB*rbC).trace());
        result -= ggA*((rbB*brC).trace());
        result += ggA*((rrB*bbC).trace());
        //  ---
        result -= gbA*((bgB*rrC).trace());
        result += gbA*((brB*rgC).trace());
        result += gbA*((rgB*brC).trace());
        result -= gbA*((rrB*bgC).trace());
        //  --- --- ---
        result += brA*((rgB*gbC).trace());
        result -= brA*((rbB*ggC).trace());
        result -= brA*((ggB*rbC).trace());
        result += brA*((gbB*rgC).trace());
        //  ---
        result += bgA*((rbB*grC).trace());
        result -= bgA*((rrB*gbC).trace());
        result -= bgA*((gbB*rrC).trace());
        result += bgA*((grB*rbC).trace());
        //  ---
        result -= bbA*((rgB*grC).trace());
        result += bbA*((rrB*ggC).trace());
        result += bbA*((ggB*rrC).trace());
        result -= bbA*((grB*rgC).trace());

      break;
    }

//     std::cout << result << std::endl;
//     std::cout << "trace: " << result.trace() << std::endl;

    std::copy(result.d_data, result.d_data + 16, d_data);
  }










}

