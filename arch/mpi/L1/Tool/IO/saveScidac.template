template< typename Element >
void Tool::IO::saveScidac(Core::Field< Element > const &field, std::string const &filename)
{
  Base::Weave weave(field.L(), field.T());

  weave.barrier();

  if (weave.dim(Base::idx_X) > 1 ||
      weave.dim(Base::idx_Y) > 1 ||
      weave.dim(Base::idx_Z) > 1)
  {
    std::cerr << "parallel writing does not work for parallalization in spatial directions" << std::endl;
    exit(1);
  }

  int const nprocs((weave.d_grid.grid()).Get_size());
  int const rank((weave.d_grid.grid()).Get_rank());

  // the main work has to be done by the writer holding the element at the origin
  int const root_rank = weave.d_grid.rank(size_t(0));

  assert (nprocs == int(weave.dim(Base::idx_T)));

  unsigned long elem_offset(weave.globalVolume());

  // each node has to find his own offset
  for (size_t my_offset = 0; my_offset < weave.globalVolume();
       my_offset += weave.localVolume())
  {
    if ((unsigned int)(rank) == weave.d_grid.rank(my_offset))
    {
      elem_offset = (unsigned long)(my_offset);
      break;
    }
  }
  assert(elem_offset < weave.globalVolume());

  weave.barrier();



  bool OK = false;

  // FIX THIS: this is a workaround because sometimes the fstream does not write the lime header
  // (for some unresoled reason)
  do
  {
    {
      size_t pos = 0;

      // 2nd argument is boolean and determines whether the writer is allowed to write the header,
      // which only the writer of the process holding the Element(s) to be written first may do
      Lime::Writer writer(filename, rank == root_rank);

      assert(writer.good());

      weave.barrier();

      if (rank == root_rank)
      {
        std::cout << "writing file " << filename << "..." << std::endl;

        writer.newRecord("propagator-type", pos, 0);

        std::string const info_string_1("DiracFermion_Sink");
        writer.write(info_string_1.c_str(), uint64_t(info_string_1.length()*sizeof(char)));
        writer.finishMessage();
        pos = writer.closeRecord();

        std::cout << "record 1 (info) written, " << std::flush;

        writer.newRecord("etmc-propagator-format",pos, 0);

        std::string info_string;
        info_string.reserve(512);
        std::ostringstream oss;
        oss << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<etmcFormat>\n<field>diracFermion</field>\n";
        oss << "<precision>64</precision>\n";
        oss << "<flavours>1</flavours>\n";
        oss << "<lx>" << field.L() << "</lx>\n";
        oss << "<ly>" << field.L() << "</ly>\n";
        oss << "<lz>" << field.L() << "</lz>\n";
        oss << "<lt>" << field.T() << "</lt>\n";
        oss << "</etmcFormat>";
        info_string = oss.str();
        writer.write(info_string.c_str(), uint64_t(info_string.length()*sizeof(char)));
        writer.finishMessage();
        pos = writer.closeRecord();

        std::cout << " record 2 (info) written,\n";
        std::cout << "preparing for parallel writing of record 3 (data) ..." << std::flush;

        writer.newRecord("scidac-binary-data", pos, weave.globalVolume() * sizeof(Element));
        writer.seekp(0);
        char dummy[sizeof(Element)];
        std::fill_n(dummy, sizeof(Element), char(0));
        writer.fill(reinterpret_cast< Element &>(*dummy), weave.globalVolume());
        assert(writer.good());
        std::cout << " done." << std::endl;
      }
      weave.broadcast(&pos, 1, root_rank);
      weave.barrier();

      // all processes but one have been idle so far and have to catch up
      if(rank != root_rank)
      {
        writer.newRecord("scidac-binary-data", pos, weave.globalVolume() * sizeof(Element));
        assert(writer.good());
      }

      weave.barrier();

      size_t const elements = sizeof(Element) / sizeof(double);

      // each writer jumps to the position it is supposed to start writing at
      writer.seekp(elem_offset * sizeof(Element));

      assert(writer.good());

      if (weave.isRoot())
        std::cout << "writing record 3 (data) ..." << std::flush;

      double buffer[elements];
      for (size_t siteIdx = 0; siteIdx < field.size(); ++siteIdx)
      {
        std::copy(reinterpret_cast< double const* >(&(field.constPhysicalIndex(siteIdx))),
                  reinterpret_cast< double const* >(&(field.constPhysicalIndex(siteIdx))) + elements, buffer);
        if (!Base::bigEndian)
        {
          Base::swapEndian(buffer, buffer + elements, sizeof(double));
        }
        writer.write(buffer, elements);
      }

      writer.finishMessage();
      writer.closeRecord();

      assert(writer.good());
    }
    weave.barrier();

    if (weave.isRoot())
      std::cout << " done.\nwill now check file ... " << std::flush;

    weave.barrier();

    if(rank == root_rank)
    {
      std::ifstream fileChecker(filename.c_str());
      assert(fileChecker.good());
      int dummy = fileChecker.get();
      fileChecker.seekg(144);
      char dummyData = fileChecker.get();
      fileChecker.close();
      OK = bool(dummy != 0 && dummyData == 'D');

      if (OK)
        std::cerr << "OK!" << std::endl;
      else
      {
        std::cerr << "not OK, trying again!" << std::endl;
      }
    }

    weave.broadcast(&OK, 1, root_rank);

    weave.barrier();

    if (!OK)
      exit(1);
  }
  while(!OK);

}
