namespace Gauge
{
  namespace Construct
  {
    template< size_t L, size_t T >
    std::complex< double > Gauge::Construct::plaquette(Core::Field< QCD::Gauge, L, T > &field, Core::SpaceTimeIndex first, Core::Direction dirFirst, Core::SpaceTimeIndex second, Core::Direction dirSecond)
    {
      Core::Buffer< SU3::Matrix > track(field.grid(), SU3::Matrix::identity());
      if (dirFirst == Core::dir_UP && dirSecond == Core::dir_UP)
      {
        track.rightMultiply(field.component(first));
        field.shift(first, Core::dir_UP);
        track.rightMultiply(field.component(second));
        field.shift(second, Core::dir_UP);
        field.shift(first, Core::dir_DOWN);
        track.rightMultiply(field.component(first).dagger());
        field.shift(second, Core::dir_DOWN);
        track.rightMultiply(field.component(second).dagger());
      }
      if (dirFirst == Core::dir_DOWN && dirSecond == Core::dir_UP)
      {
        field.shift(first, Core::dir_DOWN);
        track.rightMultiply(field.component(first).dagger());
        track.rightMultiply(field.component(second));
        field.shift(towards, Core::dir_UP);
        track.rightMultiply(field.component(first));
        field.shift(over, Core::dir_UP);
        field.shift(towards, Core::dir_DOWN);
        track.rightMultiply(field.component(second).dagger());
      }
      if (dirFirst == Core::dir_UP && dirSecond == Core::dir_DOWN)
      {
        track.rightMultiply(field.component(first));
        field.shift(over, Core::dir_UP);
        field.shift(second, Core::dir_DOWN);
        track.rightMultiply(field.component(second).dagger());
        field.shift(first, Core::dir_DOWN);
        track.rightMultiply(field.component(first).dagger());
        track.rightMultiply(field.component(second));
        field.shift(second, Core::dir_UP); // Back to the original position
      }
      if (dirFirst == Core::dir_UP && dirSecond == Core::dir_DOWN)
      {
        field.shift(first, Core::dir_DOWN);
        track.rightMultiply(field.component(first).dagger());
        field.shift(second, Core::dir_DOWN);
        track.rightMultiply(field.component(second).dagger());
        track.rightMultiply(field.component(first));
        field.shift(first, Core::dir_UP);
        track.rightMultiply(field.component(second));
        field.shift(second, Core::dir_UP); // Back to the original position
      }

      std::complex< double > result(0.0, 0.0);
      for (Core::Buffer< SU3::Matrix >::iterator iter = track.begin(); iter != track.end(); ++iter)
        result += tr(*iter);
      return result; // NOTE There should be a proper 'gather' tool in place for fields!
    }
  }
}
