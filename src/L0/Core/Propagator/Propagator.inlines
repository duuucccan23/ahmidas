namespace Core
{


  inline Propagator::Propagator(size_t L, size_t T, bool alloc)
    : d_references(new size_t(1)),
      colour_strides(new size_t[nColour]),
      dirac_strides(new size_t[nDirac])
  {

    colour_strides[0] = ColourStrideSink;
    colour_strides[1] = ColourStrideSource;
    dirac_strides[0]  = DiracStrideSink;
    dirac_strides[1]  = DiracStrideSource;

    if(alloc)
    {
      d_components = new Field< QCD::Tensor >(L, T);
    }
  }



  inline Propagator::Propagator(Propagator const &other)
    : d_components(other.d_components)
  {
    *d_references += 1;
  }


  inline Propagator::~Propagator()
  {
    destroy();
  }


  inline bool Propagator::loadILDG(std::vector< std::string > const filenames)
  {
//     if (nFiles == 1)
//     {
//       return true;
//     }
//     else
    if (filenames.size() == 12)
    {
      for (size_t i=0; i<filenames.size(); i++)
      {
        // maybe reinterpret_cast< Core::Field< std::complex< double > > * > is needed here
        // better: explicit conversion routine
//         (*d_components)[i*12] = Tool::IO::loadILDG< QCD::Spinor, L, T >(filenames[i]);
      }
      return true;
    }
    else
    {
      std::cerr << "Error in void Propagator::loadILDG(std::string const * const filenames, const size_t nFiles)" << std::endl;
      std::cerr << "filenames.size() should be 12" << std::endl;
      return false;
    }
  }


//   inline Propagator::iterator Propagator::begin()
//   {
//     isolate();
//     return iterator(*this, 0);
//   }
// 
// 
//   inline Propagator::iterator Propagator::end()
//   {
//     isolate();
//     return iterator(*this, d_components->spatialSize());
//   }


  inline size_t const Propagator::size() const
  {
    return d_size;
  }


}