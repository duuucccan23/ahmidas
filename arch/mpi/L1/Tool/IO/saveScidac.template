template< typename Element >
void Tool::IO::saveScidac(Core::Field< Element > const &field, std::string const &filename)
{
  Base::Weave weave(field.L(), field.T());

  weave.barrier();

  if (weave.dim(Base::idx_X) > 1 ||
      weave.dim(Base::idx_Y) > 1 ||
      weave.dim(Base::idx_Z) > 1)
  {
    std::cerr << "parallel writing does not work for parallalization in spatial directions" << std::endl;
    exit(1);
  }

  int const nprocs((weave.d_grid.grid()).Get_size());
  int const rank((weave.d_grid.grid()).Get_rank());

  // the main work has to be done by the writer holding the element at the origin
  int const root_rank = weave.d_grid.rank(size_t(0));

  assert (nprocs == int(weave.dim(Base::idx_T)));

  unsigned long elem_offset(weave.globalVolume());

  // each node has to find his own offset
  for (size_t my_offset = 0; my_offset < weave.globalVolume();
       my_offset += weave.localVolume())
  {
    if ((unsigned int)(rank) == weave.d_grid.rank(my_offset))
    {
      elem_offset = (unsigned long)(my_offset);
      break;
    }
  }
  assert(elem_offset < weave.globalVolume());

  weave.barrier();

  bool OK = false;

  // FIX THIS: this is a workaround because sometimes the fstream does not write the lime header
  // (for some unresoled reason)
  do
  {
    {
    size_t pos = 0;

    // 2nd argument is boolean and determines whether the writer is allowed to write the header,
    // which only the writer of the process holding the Element(s) to be written first may do
    Lime::Writer writer(filename, rank == root_rank);
    assert(writer.good());

    writer.newRecord("propagator-type", pos, 0);

    if (rank == root_rank)
    {
      std::string const info_string("DiracFermion_Sink");
      writer.write(info_string.c_str(), uint64_t(info_string.length()*sizeof(char)));
    }
    writer.finishMessage();
    pos = writer.closeRecord();

    weave.broadcast(&pos, 1, root_rank);

    writer.newRecord("etmc-propagator-format",pos, 0);

    if (rank == root_rank)
    {
      std::string info_string;
      info_string.reserve(512);
      std::ostringstream oss;
      oss << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<etmcFormat>\n<field>diracFermion</field>\n";
      oss << "<precision>64</precision>\n";
      oss << "<flavours>1</flavours>\n";
      oss << "<lx>" << field.L() << "</lx>\n";
      oss << "<ly>" << field.L() << "</ly>\n";
      oss << "<lz>" << field.L() << "</lz>\n";
      oss << "<lt>" << field.T() << "</lt>\n";
      oss << "</etmcFormat>";
      info_string = oss.str();

      writer.write(info_string.c_str(), uint64_t(info_string.length()*sizeof(char)));
    }
    writer.finishMessage();
    pos = writer.closeRecord();

    weave.barrier();

    weave.broadcast(&pos, 1, root_rank);

    writer.newRecord("scidac-binary-data", pos, weave.globalVolume() * sizeof(Element));

    weave.barrier();

    assert(writer.good());

    size_t const elements = sizeof(Element) / sizeof(double);

    // each writer jumps to the position it is supposed to start writing at
    writer.seekp(elem_offset * sizeof(Element));

    assert(writer.good());

    double buffer[elements];
    for (size_t siteIdx = 0; siteIdx < field.size(); ++siteIdx)
    {
      std::copy(reinterpret_cast< double const* >(&(field.constPhysicalIndex(siteIdx))),
                reinterpret_cast< double const* >(&(field.constPhysicalIndex(siteIdx))) + elements, buffer);
      if (!Base::bigEndian)
      {
        Base::swapEndian(buffer, buffer + elements, sizeof(double));
      }
      writer.write(buffer, elements);
    }

    writer.finishMessage();
    writer.closeRecord();
    }

    weave.barrier();

    if(rank == root_rank)
    {
      std::ifstream fileChecker(filename.c_str());
      assert(fileChecker.good());
      int dummy = fileChecker.get();
      fileChecker.seekg(144);
      char dummyData = fileChecker.get();
      fileChecker.close();
      OK = bool(dummy != 0 && dummyData == 'D');

      if (OK)
        std::cerr << "OK! " << dummyData << std::endl;
      else
        std::cerr << "not OK! " << dummyData << std::endl;
    }

    weave.broadcast(&OK, 1, root_rank);

    weave.barrier();
  }
  while(!OK);

}
