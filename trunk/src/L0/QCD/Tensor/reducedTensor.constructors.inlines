namespace QCD
{

  // private constructor
  inline reducedTensor::reducedTensor(Tensor const &fullTensor, Base::ColourIndex const colour_src, Base::ColourIndex const colour_snk)
  {
    size_t index = 12*colour_src + colour_snk;
    d_data[ 0] = fullTensor.d_data[index     ];
    d_data[ 1] = fullTensor.d_data[index +   3];
    d_data[ 2] = fullTensor.d_data[index +   6];
    d_data[ 3] = fullTensor.d_data[index +   9];
    d_data[ 4] = fullTensor.d_data[index +  36];
    d_data[ 5] = fullTensor.d_data[index +  39];
    d_data[ 6] = fullTensor.d_data[index +  42];
    d_data[ 7] = fullTensor.d_data[index +  45];
    d_data[ 8] = fullTensor.d_data[index +  72];
    d_data[ 9] = fullTensor.d_data[index +  75];
    d_data[10] = fullTensor.d_data[index +  78];
    d_data[11] = fullTensor.d_data[index +  81];
    d_data[12] = fullTensor.d_data[index + 108];
    d_data[13] = fullTensor.d_data[index + 111];
    d_data[14] = fullTensor.d_data[index + 114];
    d_data[15] = fullTensor.d_data[index + 117];
  }

  inline reducedTensor::reducedTensor()
  {
    //std::fill(d_data, d_data + 16, std::complex< double >(0.0, 0.0));
  }

  inline reducedTensor::reducedTensor(std::complex< double > const& value)
  {
    std::fill_n(d_data, 16, value);
  }


  inline reducedTensor::reducedTensor(reducedTensor const &other)
  {
    std::copy(other.d_data, other.d_data + 16, d_data);
  }


  /* the following constructors are used to perform contractions */

  inline reducedTensor::reducedTensor(Tensor const &A, Tensor const &B)
  {

    reducedTensor rr(A, Base::col_RED,   Base::col_RED);
    reducedTensor rg(A, Base::col_RED,   Base::col_GREEN);
    //std::cout << "rg = \n" << rg << std::endl;
    reducedTensor rb(A, Base::col_RED,   Base::col_BLUE);
    reducedTensor gr(A, Base::col_GREEN, Base::col_RED);
    //std::cout << "gr = \n" << gr << std::endl;
    //exit(1);
    reducedTensor gb(A, Base::col_GREEN, Base::col_BLUE);
    reducedTensor gg(A, Base::col_GREEN, Base::col_GREEN);
    reducedTensor br(A, Base::col_BLUE,  Base::col_RED);
    reducedTensor bb(A, Base::col_BLUE,  Base::col_BLUE);
    reducedTensor bg(A, Base::col_BLUE,  Base::col_GREEN);

    rr *= reducedTensor(B, Base::col_RED,   Base::col_RED);
    rg *= reducedTensor(B, Base::col_GREEN, Base::col_RED);
    rb *= reducedTensor(B, Base::col_BLUE,  Base::col_RED);
    gr *= reducedTensor(B, Base::col_RED,   Base::col_GREEN);
    gb *= reducedTensor(B, Base::col_BLUE,  Base::col_GREEN);
    gg *= reducedTensor(B, Base::col_GREEN, Base::col_GREEN);
    br *= reducedTensor(B, Base::col_RED,   Base::col_BLUE);
    bb *= reducedTensor(B, Base::col_BLUE,  Base::col_BLUE);
    bg *= reducedTensor(B, Base::col_GREEN, Base::col_BLUE);

    rr += rg;
    rr += rb;
    rr += gr;
    rr += gb;
    rr += gg;
    rr += br;
    rr += bb;
    rr += bg;

    std::copy(rr.d_data, rr.d_data + 16, d_data);
  }

  /*  For a white source propagator we can use a faster constructor
      since we know which entries of the tensors are zero.
      This constructor is in particular used for of Dirac-diluted
      stochastic propagators, and therefore important in appication
      of the one-end-trick.
  */
  inline reducedTensor::reducedTensor(Tensor const &A, Tensor const &B, bool const colourDilutedSource)
  {
    if (!colourDilutedSource)
    {
      // note that "RED" as the "source" index actually addresses the only non-zero entries
      reducedTensor xr(A, Base::col_RED,   Base::col_RED);
      reducedTensor xg(A, Base::col_RED,   Base::col_GREEN);
      reducedTensor xb(A, Base::col_RED,   Base::col_BLUE);

      // note that second Tensor is suppoed to appear as a
      // hermitian conjugate one, so source and sink indices are swapped
      xr *= reducedTensor(B, Base::col_RED,   Base::col_RED);
      xg *= reducedTensor(B, Base::col_GREEN, Base::col_RED);
      xb *= reducedTensor(B, Base::col_BLUE,  Base::col_RED);

      xr += xg;
      xr += xb;
      std::copy(xr.d_data, xr.d_data + 16, d_data);
    }
    else if (colourDilutedSource)
      *this = reducedTensor(A, B);
  }

}

