namespace Base
{
  inline size_t Weave::dim(Base::SpaceTimeIndex idx) const
  {
    return d_grid.dim(idx);
  }

  inline size_t Weave::localSize(Base::SpaceTimeIndex idx) const
  {
    return d_localSize[idx];
  }

  inline size_t Weave::localSurface(Base::SpaceTimeIndex idx) const
  {
    return d_surfaces[idx];
  }

  inline size_t Weave::localVolume() const
  {
    return d_localVolume;
  }

  inline size_t Weave::globalVolume() const
  {
    return d_globalVolume;
  }

  inline size_t Weave::L() const
  {
    return d_L;
  }

  inline size_t Weave::T() const
  {
    return d_T;
  }

  inline double Weave::sum(double result) const
  {
    double all_result;
    d_grid.grid().Allreduce(static_cast< const void * >(&result), static_cast< void * >(&all_result),
                           1, MPI_DOUBLE, MPI_SUM);
    return all_result;
  }

  // SD: this is quite inefficient, but will do the job.
  // btw, where do we actually need this?
  inline bool Weave::isLocallyAvailable(size_t const x, size_t const y, size_t const z) const
  {
    for (size_t t=0; t<d_T; t++)
    {
      if ((d_grid.grid()).Get_rank() == d_grid.rank(t * d_L * d_L * d_L +
                                                    z * d_L * d_L +
                                                    y * d_L + x))
      {
        return true;
      }
    }
    return false;
  }

  inline bool Weave::isLocallyAvailable(size_t const x, size_t const y, size_t const z, size_t const t) const
  {
    return (d_grid.grid()).Get_rank() == d_grid.rank(t * d_L * d_L * d_L +
                                                     z * d_L * d_L +
                                                     y * d_L + x);
  }

  inline bool Weave::isRoot() const
  {
    return d_grid.grid().Get_rank() == 0;
  }

  inline size_t Weave::fromGlobal(size_t const idx, Base::SpaceTimeIndex const mu) const
  {
//     std::cout << "Weave::fromGlobal(" << idx << ", " << mu << ") = "
//               << idx <<"%" << d_localSize[mu] << " = "
//               << idx % d_localSize[mu] << std::endl;
    return idx % d_localSize[mu];
  }

  inline size_t Weave::globalCoordToLocalIndex(size_t const x, size_t const y, size_t const z) const
  {
    if (!isLocallyAvailable(x, y, z))
      return d_localVolume; // this is our error condition
    return (fromGlobal(x, Base::idx_X) * localSurface(Base::idx_X) + fromGlobal(y, Base::idx_Y) * localSurface(Base::idx_Y)
            + fromGlobal(z, Base::idx_Z) * localSurface(Base::idx_Z));
  }

  inline size_t Weave::globalCoordToLocalIndex(size_t const x, size_t const y, size_t const z, size_t const t) const
  {
    if (!isLocallyAvailable(x, y, z, t))
      return d_localVolume; // error condition
    return (fromGlobal(x, Base::idx_X) * localSurface(Base::idx_X) + fromGlobal(y, Base::idx_Y) * localSurface(Base::idx_Y)
            + fromGlobal(z, Base::idx_Z) * localSurface(Base::idx_Z) + fromGlobal(t, Base::idx_T) * localSurface(Base::idx_T));
  }

  template< typename Element >
  inline void Weave::broadcast(Element *data, size_t const count, int root) const
  {
    MPI_Bcast(data, count * sizeof(Element), MPI_BYTE, root, d_grid.grid());
  }

  inline size_t Weave::rank() const
  {
    return d_grid.rank();
  }

  inline size_t Weave::rank(size_t index) const
  {
    return d_grid.rank(index);
  }

  inline size_t Weave::rank(size_t const *coords) const
  {
    return d_grid.rank(coords);
  }
}