template< typename Element >
void Base::Weave::fieldShift(Base::SpaceTimeIndex idx, Base::Direction dir, Element *field, size_t const *offsets) const
{
  // Determine what to send
  // Create a basic datatype for the element -- we want to be agnostic about this
  MPI_Datatype etype;
  MPI_Type_contiguous(sizeof(Element), MPI_BYTE, &etype);
  MPI_Type_commit(&etype);

  // Set up arrays for the MPI subarray
  int sizes[4];
  std::copy(d_grid.sizes(), d_grid.sizes() + 4, sizes);

  int subsizes[4];
  std::copy(sizes, sizes + 4, subsizes);
  subsizes[idx] = 1;

  int starts[4];
  std::fill(starts, starts + 4, 0);
  starts[idx] = offsets[idx];
  if (dir == dir_DOWN)
    starts[idx] = (starts[idx] + sizes[idx] - 1) % sizes[idx];

  // Create a subarray for the surface we need
  MPI_Datatype surface;
  MPI_Type_create_subarray(4, sizes, subsizes, starts, MPI_ORDER_C, etype, &surface);
  MPI_Type_commit(&surface);

  // Send the data indicated by the subarray to our neighbours
  MPI_Status status;
  Base::Direction opp_dir = (dir == dir_UP) ? dir_DOWN : dir_UP;
  MPI_Sendrecv_replace(field, 1, surface,
                       d_grid.neighbour(idx, dir) /* destination */, 1 /* sendtag */,
                       d_grid.neighbour(idx, opp_dir) /* source */, 1 /* recvtag */,
                       d_grid.grid(), &status);

  // Clear up any resources we claimed
  MPI_Type_free(&surface);
  MPI_Type_free(&etype);
}
