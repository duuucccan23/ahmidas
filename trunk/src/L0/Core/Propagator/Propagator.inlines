namespace Core
{
  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline Propagator< L, T, nDirac, nColour >::Propagator()
    : d_references(new size_t(1)),
      d_components(new Field< std::complex< double >, L, T > *[(size_t)std::pow(4,Dirac)*(size_t)std::pow(3,Colour)]),
      color_strides(new size_t[nColour]),
      dirac_strides(new size_t[nDirac])
  {

    for (size_t idx=0; idx<size(); idx++)
      d_components[idx] = new Field< std::complex< double >, L, T >;
    
    for (size_t idx=0; idx<nColour; idx++)
      delete color_strides[idx];
    delete [] colour_strides;
    for (size_t idx=0; idx<nDirac; idx++)
      delete dirac_strides[idx];
    delete [] dirac_strides;
  }
  
  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline Propagator< L, T, nDirac, nColour >::Propagator(Propagator< L, T, nDirac, nColour > const &other)
    : d_components(other.d_components)
  {
    *d_references += 1;
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline Propagator< L, T, nDirac, nColour >::~Propagator()
  {
    destroy();
  }
  
  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline void Propagator< L, T, nDirac, nColour >::getStrides()
  {
    if (Colour > 0)
    {
      colour_strides = new size_t[Colour];
      for (size_t idx = 0; idx<Colour; ++idx)
        colour_strides[idx] = (size_t)pow(3, Colour-idx) * (size_t)pow(4, Dirac > idx ? Dirac-idx : 0);
    }
    else 
      colour_strides = 0;
    if (Dirac > 0)
    {
      dirac_strides = new size_t[Dirac];
      for (size_t idx = 0; idx<Dirac; ++idx)
        dirac_strides[idx] = (size_t)pow(3, Colour-idx < 0 ? 0 : Colour-idx+1) * (size_t)pow(4, Dirac-idx-1);
    }
    else 
      dirac_strides = 0;
  }
  
 
  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline typename Propagator< L, T, nDirac, nColour >::iterator_full Propagator< L, T, nDirac, nColour >::begin()
  {
    isolate();
    return iterator_full();
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline typename Propagator< L, T, nDirac, nColour >::iterator_full Propagator< L, T, nDirac, nColour >::end()
  {
    isolate();
    return iterator_full();
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline typename Propagator< L, T, nDirac, nColour >::const_iterator_full Propagator< L, T, nDirac, nColour >::begin() const
  {
    return const_iterator_full(d_components);
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline typename Propagator< L, T, nDirac, nColour >::const_iterator_full Propagator< L, T, nDirac, nColour >::end() const
  {
    return const_iterator_full(d_components + 12);
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline typename Propagator< L, T, nDirac, nColour >::iterator_colour Propagator< L, T, nDirac, nColour >::begin(Base::ColourIndex const index)
  {
    isolate();
    return iterator_colour(d_components + index);
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline typename Propagator< L, T, nDirac, nColour >::iterator_colour Propagator< L, T, nDirac, nColour >::end(Base::ColourIndex const index)
  {
    isolate();
    return iterator_colour(d_components + index + 12);
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline typename Propagator< L, T, nDirac, nColour >::const_iterator_colour Propagator< L, T, nDirac, nColour >::begin(Base::ColourIndex const index) const
  {
    return const_iterator_colour(d_components + index);
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline typename Propagator< L, T, nDirac, nColour >::const_iterator_colour Propagator< L, T, nDirac, nColour >::end(Base::ColourIndex const index) const
  {
    return const_iterator_colour(d_components + index + 12);
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline typename Propagator< L, T, nDirac, nColour >::iterator_dirac Propagator< L, T, nDirac, nColour >::begin(Base::DiracIndex const index)
  {
    isolate();
    return iterator_dirac(d_components + 3 * index);
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline typename Propagator< L, T, nDirac, nColour >::iterator_dirac Propagator< L, T, nDirac, nColour >::end(Base::DiracIndex const index)
  {
    isolate();
    return iterator_dirac(d_components + 3 * (index + 1));
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline typename Propagator< L, T, nDirac, nColour >::const_iterator_dirac Propagator< L, T, nDirac, nColour >::begin(Base::DiracIndex const index) const
  {
    return const_iterator_dirac(d_components + 3 * index);
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline typename Propagator< L, T, nDirac, nColour >::const_iterator_dirac Propagator< L, T, nDirac, nColour >::end(Base::DiracIndex const index) const
  {
    return const_iterator_dirac(d_components + 3 * (index + 1));
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline size_t Propagator< L, T, nDirac, nColour >::size() const
  {
    return (size_t)std::pow(4,Dirac)*(size_t)std::pow(3,Colour);
  }



//   template< size_t L, size_t T, size_t nDirac, size_t nColour >
//   inline Propagator< L, T, Dirac-1, Colour > &Propagator< L, T, nDirac, nColour >::getDirac(Base::DiracIndex const dirIdx,
//                                                                                           size_t const DiracID)
//   {
//     assert(Dirac>0);
//     isolate();
//     size_t stride = dirac_stride[DiracID];
//     size_t offset = dirIdx*dirac_stride[DiracID];
//     Propagator< L, T, Dirac-1, Colour > tmp_prop;
//     // NOTE this has to be done more efficiently, need new constructor that leaves d_components empty
//     // what if Propagator< L, T, nDirac, nColour > is deleted?!
//     delete [] d_components;
//     // check again carefully - I think this is not working well for Dirac > 2
//     for (size_t idx=0; idx<tmp_prop.size(); idx++)
//       tmp_prop.d_components[idx] = d_components[idx%stride+4*idx/stride+offset];
//     return tmp_prop;
//   }  
//   
//   template< size_t L, size_t T, size_t nDirac, size_t nColour >
//   inline Propagator< L, T, Dirac-1, Colour > const &Propagator< L, T, nDirac, nColour >::getDirac(Base::DiracIndex const dirIdx,
//                                                                                                 size_t const DiracID)
//   {
//     assert(Dirac>0);
//     size_t stride = dirac_stride[DiracID];
//     size_t offset = dirIdx*dirac_stride[DiracID];
//     Propagator< L, T, Dirac-1, Colour > tmp_prop;
//     delete [] d_components;
//     for (size_t idx=0; idx<tmp_prop.size(); idx++)
//       tmp_prop.d_components[idx] = d_components[idx%stride+4*idx/stride+offset];
//     return tmp_prop;
//   }
// 
//   template< size_t L, size_t T, size_t nDirac, size_t nColour >
//   inline Propagator< L, T, nDirac, nColour-1 > &Propagator< L, T, nDirac, nColour >::getColour(Base::ColourIndex const dirIdx,
//                                                                                            const size_t ColourID)
//   {
//     isolate();
//     assert(Colour>0);
//     size_t stride = colour_stride[ColourID];
//     size_t offset = dirIdx*dirac_stride[DiracID];
//     Propagator< L, T, Dirac-1, Colour > tmp_prop;
//     delete [] d_components;
//     for (size_t idx=0; idx<tmp_prop.size(); idx++)
//       tmp_prop.d_components[idx] = d_components[idx%stride+3*idx/stride+offset];
//     return tmp_prop;
//   }
// 
//   template< size_t L, size_t T, size_t nDirac, size_t nColour >
//   inline Propagator< L, T, nDirac, nColour-1 > const &Propagator< L, T, nDirac, nColour >::getColour(Base::ColourIndex const dirIdx,
//                                                                                                  const size_t ColourID)
//   {
//     isolate();
//     assert(Colour>0);
//     size_t stride = colour_stride[ColourID];
//     size_t offset = dirIdx*dirac_stride[DiracID];
//     Propagator< L, T, Dirac-1, Colour > tmp_prop;
//     delete [] d_components;
//     for (size_t idx=0; idx<tmp_prop.size(); idx++)
//       tmp_prop.d_components[idx] = d_components[idx%stride+3*idx/stride+offset];
//     return tmp_prop;
//   }


  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline view< L, T, nDirac-1, nColour > &Propagator< L, T, nDirac, nColour >::operator()(Base::DiracIndex const idx, 
                                                                                          size_t const DiracID)
  {
    return view< L, T, nDirac-1, nColour >(this, idx, DiracID);
  }
  
  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline view< L, T, nDirac, nColour-1 > &Propagator< L, T, nDirac, nColour >::operator()(Base::ColourIndex const idx,
                                                                                          size_t const ColourID)
  {
    return view< L, T, nDirac, nColour-1 >(this, idx, ColourID);
  }


  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline Propagator< L, T, Dirac-1, Color-1 > &Propagator< L, T, nDirac, nColour >::operator()(Base::ColourIndex const colIdx,
                                                                                             Base::DiracIndex const dirIdx,
                                                                                             const size_t ColorID,
                                                                                             const size_t DiracID)
  {
    isolate();
    getDirac(dirIdx, DiracID).getColour(colIdx);
    return d_components[colIdx + 3 * dirIdx];
  }

  template< size_t L, size_t T, size_t nDirac, size_t nColour >
  inline Core::Field< QCD::Spinor, L, T > const &Propagator< L, T, nDirac, nColour >::operator()(Base::ColourIndex const colIdx,
                                                                                              Base::DiracIndex const dirIdx,
                                                                                              const size_t ColorID,
                                                                                              const size_t DiracID)
  {
    return d_components[colIdx + 3 * dirIdx];
  }
  
}
