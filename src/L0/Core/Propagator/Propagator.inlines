namespace Core
{


  inline Propagator::Propagator(size_t L, size_t T, bool alloc)
    : d_references(new size_t(1)),
      colour_strides(new size_t[nColour]),
      dirac_strides(new size_t[nDirac])
  {

    colour_strides[0] = ColourStrideSink;
    colour_strides[1] = ColourStrideSource;
    dirac_strides[0]  = DiracStrideSink;
    dirac_strides[1]  = DiracStrideSource;

    if(alloc)
    {
      d_components = new Field< QCD::Tensor >(L, T);
    }
  }



  inline Propagator::Propagator(Propagator const &other)
    : d_references(other.d_references), 
      d_components(other.d_components),
      colour_strides(other.colour_strides),
      dirac_strides(other.dirac_strides)
  {
    *d_references += 1;
  }


  inline Propagator::~Propagator()
  {
    destroy();
  }


  inline bool Propagator::load(std::vector< std::string > const filenames, std::string const format)
  {
    isolate();
    if (d_components == NULL)
    {
      std::cerr << "Error in void Propagator::loadILDG(std::vector< std::string > const filenames):" << std::endl;
      std::cerr << "memory for member Core::Field< QCD::Tensor > Propagator::d_components not allocated" << std::endl;
      return false;
    }

    if (filenames.size() == 12)
    {
      Core::Field< QCD::Spinor > tmp [12] =
      {
        Core::Field< QCD::Spinor > (d_components->L(), d_components->T()),
        Core::Field< QCD::Spinor > (d_components->L(), d_components->T()),
        Core::Field< QCD::Spinor > (d_components->L(), d_components->T()),
        Core::Field< QCD::Spinor > (d_components->L(), d_components->T()),
        Core::Field< QCD::Spinor > (d_components->L(), d_components->T()),
        Core::Field< QCD::Spinor > (d_components->L(), d_components->T()),
        Core::Field< QCD::Spinor > (d_components->L(), d_components->T()),
        Core::Field< QCD::Spinor > (d_components->L(), d_components->T()),
        Core::Field< QCD::Spinor > (d_components->L(), d_components->T()),
        Core::Field< QCD::Spinor > (d_components->L(), d_components->T()),
        Core::Field< QCD::Spinor > (d_components->L(), d_components->T()),
        Core::Field< QCD::Spinor > (d_components->L(), d_components->T())
      };

      for (size_t i=0; i<12; i++)
      {
        if (format == std::string("ILDG"))
         tmp[i] = Tool::IO::loadILDG< QCD::Spinor >(filenames[i], d_components->L(), d_components->T());
        else if (format == std::string("Scidac"))
        {
          tmp[i] = Tool::IO::loadScidac< QCD::Spinor >(filenames[i], d_components->L(), d_components->T());
          //std::cout << (tmp[i])[0]; //exit(1);
        }
        else
        {
          std::cerr << "File format " << format << " not known or not implemented yet, choose one of the following:\n";
          std::cerr << "ILDG\n";
          std::cerr << "Scidac\n";
          return false;
        }
      }

      Core::Field< QCD::Tensor >::iterator itTensor = d_components->begin();
      Core::Field< QCD::Spinor >::iterator itsSpinor [12] =
      {
        tmp[ 0].begin(),tmp[ 1].begin(),tmp[ 2].begin(),
        tmp[ 3].begin(),tmp[ 4].begin(),tmp[ 5].begin(),
        tmp[ 6].begin(),tmp[ 7].begin(),tmp[ 8].begin(),
        tmp[ 9].begin(),tmp[10].begin(),tmp[11].begin()
      };

      QCD::Spinor **spinors = new QCD::Spinor *[12];
      for (size_t i=0; i<12; i++)
        spinors[i] = NULL;

      // would like to see for loop here
      // but postfix Field::iterator operator++(int) is not implemented yet
      do
      {
        for (size_t i=0; i<12; i++)
        {
          spinors[i] = new QCD::Spinor(*(itsSpinor[i]));
          //std::cout << *(spinors[i]) << std::endl;
          ++(itsSpinor[i]);
        }
        *(itTensor) = QCD::Tensor(spinors);
        for (size_t i=0; i<12; i++)
        {
          delete spinors[i];
        }
      }
      while (++itTensor != d_components->end());

     delete [] spinors;

      return true;
    }
    else
    {
      std::cerr << "Error in void Propagator::loadILDG(std::vector< std::string > const filenames):" << std::endl;
      std::cerr << "filenames.size() should be 12" << std::endl;
      return false;
    }
  }

//   inline Propagator *Propagator::revert() const
//   {
//     Dirac::Gamma<5> gamma5 =  Dirac::Gamma<5>();
//     Propagator *p = new Propagator(L(), T());
//     p->isolate();
//     Propagator::const_iterator before = begin();
//     Propagator::iterator after  = p->begin();
//     while(before != end())
//     {
//       (*after) = ((*before) * gamma5).dagger();
//       (*after) *= gamma5;
//       ++after;
//       ++before;
//     }
//     assert(before==end() && after==p->end());
//     return p;
//   }

  inline void Propagator::revert()
  {
    Dirac::Gamma<5> gamma5 = Dirac::Gamma<5>();
    isolate();
    Propagator::iterator it = begin();
    while(it != end())
    {
      QCD::Tensor tmp((*it).dagger());
      tmp *= gamma5;
      (*it) = gamma5*tmp;
      ++it;
    }
  }

  inline void Propagator::dagger()
  {
    isolate();
    Propagator::iterator it = begin();
    while(it != end())
    {
      (*it) = QCD::Tensor((*it).dagger());
      ++it;
    }
  }

  inline double Propagator::diff(Propagator const& other) const
  {
    if (d_components == other.d_components)
      return 0.0;
    if (L() != other.L() || T() != other.T())
      return -1.0;

    double diff(0.0);

    Propagator::const_iterator it1 = begin();
    Propagator::const_iterator it2 = other.begin();

    while(it1 != end())
    {
      diff += abs((*it1).diff(*it2));
      ++it2;
      ++it1;
    }
    diff /= (double(d_components->volume())*double(size()));
    return diff;
  }

  inline void Propagator::setToRandom()
  {
    isolate();
    Propagator::iterator it = begin();
    while(it != end())
    {
      (*it).setToRandom();
      ++it;
    }
  }

  inline Propagator::iterator Propagator::begin()
  {
    isolate();
    return iterator(*this, 0);
  }

  inline Propagator::const_iterator Propagator::begin() const
  {
    return const_iterator(*this, 0);
  }

  inline Propagator::iterator Propagator::end()
  {
    isolate();
    return iterator(*this, d_components->size());
  }

  inline Propagator::const_iterator Propagator::end() const
  {
    return const_iterator(*this, d_components->size());
  }

  inline size_t const Propagator::size() const
  {
    return d_size;
  }

  inline size_t const Propagator::L() const
  {
    return d_components->L();
  }

  inline size_t const Propagator::T() const
  {
    return d_components->T();
  }



}
