template< typename Element >
void Tool::IO::loadScidac(Core::Field< Element > *field, std::string const &filename)
{
  
  Base::Weave weave(field->L(), field->T());
  
  int nprocs((weave.d_grid.grid()).Get_size());
  int rank((weave.d_grid.grid()).Get_rank());
  
  unsigned long elem_offset(0);
  
  for (int irank=0; irank<nprocs; irank++)
  {
    (weave.d_grid.grid()).Barrier();
    
    if (irank != rank)
      continue;
    
    Lime::Reader reader(filename);
    Scidacinfo info(reader);

    reader.retrieveRecord(reader.findRecord("scidac-binary-data"));
    if (reader.fail())
    {
      std::cerr << "Lime reader could not find the record, check path and file, and check lime contents of file.\nField unchanged!.\n";
      exit(EXIT_FAILURE);
      return;
    }
    assert(reader.good());
    
    //go to position from which the data is supposed to be read
    reader.seekg(elem_offset*sizeof(Element), reader.findRecord("scidac-binary-data"));
    assert(reader.good());

    Element *dataPtr = field->raw(); //Starting memory address of the field.

    if (info.precision.compare("64") == 0)
    {
      reader.read(dataPtr, field->size());
      if (!Base::bigEndian)
        Base::swapEndian(dataPtr, dataPtr + field->size(), sizeof(double));
      
      elem_offset += weave.localVolume();
      (weave.d_grid.grid()).Bcast(static_cast< void * >(&elem_offset), 1, MPI_UNSIGNED_LONG, rank);
      
      return;
    }

    size_t const elSize = sizeof(Element) / sizeof(double);
    uint32_t elem32[elSize];

    for (size_t ctr = 0; ctr < field->size(); ++ctr, ++dataPtr)
    {
      reader.read(elem32, elSize);
      if (!Base::bigEndian)
        Base::swapEndian(elem32, elem32 + elSize);
      std::copy(reinterpret_cast< float* >(elem32), reinterpret_cast< float* >(elem32) + elSize,
                reinterpret_cast< double* >(dataPtr));
    }
    
    elem_offset += weave.localVolume();
    (weave.d_grid.grid()).Bcast(static_cast< void * >(&elem_offset), 1, MPI_UNSIGNED_LONG, rank);
  }
  (weave.d_grid.grid()).Barrier();
}
