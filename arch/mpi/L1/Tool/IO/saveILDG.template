template< typename Element >
void Tool::IO::saveILDG(Core::Field< Element > const &field, std::string const &filename)
{
  Base::Weave weave(field.L(), field.T());

  weave.barrier();

  int const rank((weave.d_grid.grid()).Get_rank());

  // the main work has to be done by the writer holding the element at the origin
  int const root_rank = weave.d_grid.rank(size_t(0));

  weave.barrier();

  size_t const blockSize = (weave.d_grid).contiguousBlock();
  size_t const numBlocks = weave.localVolume()/blockSize;

  size_t globalDimSize[4];
  globalDimSize[Base::idx_T] = field.L()*field.L()*field.L();
  globalDimSize[Base::idx_Z] = field.L()*field.L();
  globalDimSize[Base::idx_Y] = field.L();
  globalDimSize[Base::idx_X] = 1;

//   size_t jumpS[4] = {0, 0, 0, 0}; // information where to jump
//   size_t jumpN[4] = {weave.localVolume(), weave.localVolume(),
//                      weave.localVolume(), weave.localVolume()}; // information when to perform which jump
// 
//   if (numBlocks > 1)
//   {
//     // determine "lowest" dimension that is distributed to more than 1 process  
//     size_t idx(0);
//     while (((weave.d_grid).dim(idx) == 1) && (idx < 4))
//       ++idx;
//     assert(idx < 3); // this should not happen, because there have to be at least
//     // two distributed dimensions for more than one contiguous block per process
//     if(idx == Base::idx_Z) // assume that the index is 2
//     {
//       jumpS[idx] = globalDimSize[Base::idx_T];
//       jumpN[idx] = 1;
//     }
//     else if(idx == Base::idx_Y) // assume that the index is 1
//     {
//       jumpS[idx  ] = globalDimSize[Base::idx_Z];
//       jumpS[idx+1] = globalDimSize[Base::idx_Z]*((((weave.d_grid).dim(Base::idx_Z)-1)*(weave.d_grid).size(Base::idx_Z))+1);
//       jumpN[idx  ] = 1;
//       jumpN[idx+1] = (weave.d_grid).size(idx+1);
//     }
//     else if(idx == Base::idx_X) // assume that the index is 0
//     {
//       jumpS[idx  ] = globalDimSize[Base::idx_Y];
//       jumpS[idx+1] = globalDimSize[Base::idx_Y]*((((weave.d_grid).dim(Base::idx_Y)-1)*(weave.d_grid).size(Base::idx_Y))+1);
//       jumpS[idx+2] = jumpS[idx+1]
// 	           + globalDimSize[Base::idx_Z]*((((weave.d_grid).dim(Base::idx_Z)-1)*(weave.d_grid).size(Base::idx_Z)));
//       jumpN[idx  ] = 1;
//       jumpN[idx+1] = (weave.d_grid).size(idx+1);
//       jumpN[idx+2] = jumpN[idx+1]*(weave.d_grid).size(idx+2);
//     }
//   }


  size_t const *coords = (weave.d_grid).coords();

  unsigned long elem_offset(0);

  // each node has to find his own offset
  for (size_t idx = 0; idx < 4; idx++)
  {
    // offset in each dimension is the process' coordinate index times the
    // global size of (one "slice" of) this direction times the local size in this direction
    elem_offset += coords[idx] * globalDimSize[idx] * ((weave.d_grid).size(idx));
  }

  assert(elem_offset < weave.globalVolume());

  weave.barrier();



  size_t pos = 0;

  Lime::Writer writer(&weave, filename);

  assert(writer.good());

  weave.barrier();

  if ( rank == root_rank )
  {
    writer.newRecord("ildg-data-lfn", 0, pos); //NOTE incomplete header for now
    writer.finishMessage();
    pos = writer.closeRecord();
  }

  // all processes should know where we are
  weave.broadcast(&pos, 1, root_rank);
  weave.barrier();

  uint64_t pre=pos+144+field.L()*field.L()*field.L()*field.T()*sizeof(Element);
  writer.preallocate(pre);

  writer.newRecord("ildg-binary-data", pos, weave.globalVolume() * sizeof(Element));
  assert(writer.good());

//   size_t const elementSize = sizeof(Element) / sizeof(double);

  double * buffer = NULL;


  if (!Base::bigEndian)
  {

    buffer = new double[fieldSize];

    std::copy(reinterpret_cast< double const * >(&(field.constPhysicalIndex(0))),
              reinterpret_cast< double const * >(&(field.constPhysicalIndex(0))) + fieldSize,
              buffer);

    Base::swapEndian(buffer, buffer + fieldSize, sizeof(double));
    writer.write_collective(reinterpret_cast< Element * >(buffer), weave.localVolume(), elem_offset*sizeof(Element));
  }
  else
  {
    writer.write_collective(&(field.constPhysicalIndex(0)), weave.localVolume(), elem_offset*sizeof(Element));
  }

  if (!Base::bigEndian)
    delete [] buffer;

  buffer = NULL;

  writer.reset_view();

  writer.finishMessage();
  writer.closeRecord();

  assert(writer.good());

  weave.barrier();

}
