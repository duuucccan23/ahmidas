namespace Core
{
  template< typename Element, size_t L, size_t T >
  void Field< Element, L, T >::increaseIdx(short *idx) const
  {
    if ((++idx[idx_Z]) % d_grid.dim(idx_Z))
      return;
    if ((++idx[idx_Y]) % d_grid.dim(idx_Y))
      return;
    if ((++idx[idx_X]) % d_grid.dim(idx_X))
      return;
    ++idx[idx_T];
  }

  template< typename Element, size_t L, size_t T >
  void Field< Element, L, T >::decreaseIdx(short *idx) const
  {
    if (--idx[idx_Z] >= 0)
      return;
    idx[idx_Z] += d_grid.dim(idx_Z);
    if (--idx[idx_Y] >= 0)
      return;
    idx[idx_Y] += d_grid.dim(idx_Y);
    if (--idx[idx_X] >= 0)
      return;
    idx[idx_X] += d_grid.dim(idx_X);
    --idx[idx_T];
  }

  template< typename Element, size_t L, size_t T >
  Field< Element, L, T > &Field< Element, L, T >::shift(SpaceTimeIndex idx, Direction dir)
  {
    size_t dest = d_grid.neighbour(idx, dir);
    std::cout << "Node " << d_grid.rank() << " sends to node " << dest << std::endl;
    if (dest == d_grid.rank()) // We're just wrapping...
    {
      d_offsets[idx] += dir + d_grid.dim(idx);
      d_offsets[idx] %= d_grid.dim(idx); // Just move (and possibly wrap) the offset
      return *this;
    }

    int source = d_grid.neighbour(idx, dir == dir_UP ? dir_DOWN : dir_UP);

    // We use a buffered send, so we should be safe from deadlocks
    void *buffer_v = d_buffer;
    MPI::Attach_buffer(buffer_v, d_grid.bufferVolume() * sizeof(Element));

    d_grid.grid().Bsend(d_field + (d_offsets[idx] * d_grid.surface(idx)), 1, d_surfaces[idx], dest, TAG_GAUGEFIELD);
    d_grid.grid().Recv(d_field + (d_offsets[idx] * d_grid.surface(idx)), 1, d_surfaces[idx], source, TAG_GAUGEFIELD);

    // Detaching the buffer provides an implicit synchronization mechanism, since we now know the buffer is cleared.
    MPI::Detach_buffer(buffer_v);

    // Now all we need to do is shift the offset to reflect the new situation
    d_offsets[idx] += dir + d_grid.dim(idx);
    d_offsets[idx] %= d_grid.dim(idx);

    return *this;
  }

  template< typename Element, size_t L, size_t T >
  Field< Element, L, T >::Field(Grid< L, T > &grid, Element const &value)
    : d_grid(grid), d_buffer(new Element[d_grid.surface()]),
      d_field(new Element[d_grid.localVolume()])
  {
    std::fill(d_field, d_field + d_grid.localVolume(), value); // NOTE There may well be more efficient methods.
    std::fill(d_offsets, d_offsets + 4, 0);
    setSurfaces();
  }

  template< typename Element, size_t L, size_t T >
  Field< Element, L, T >::Field(Field< Element, L, T > const &other, Element const &value)
    : d_grid(other.d_grid),
      d_buffer(new Element[d_grid.surface()]),
      d_field(new Element[d_grid.localVolume()])
  {
    std::fill(d_offsets, d_offsets + 4, 0);
    std::fill(d_field, d_field + d_grid.localVolume(), value);
    std::copy(other.d_surfaces, other.d_surfaces + 4, d_surfaces);
  }

  template< typename Element, size_t L, size_t T >
  Field< Element, L, T >::Field(Field< Element, L, T > const &other)
    : d_grid(other.d_grid),
      d_buffer(new Element[d_grid.surface()]),
      d_field(new Element[d_grid.localVolume()])
  {
    std::copy(other.d_offsets, other.d_offsets + 4, d_offsets);
    std::copy(other.d_field, other.d_field + d_grid.localVolume(), d_field);
    std::copy(other.d_surfaces, other.d_surfaces + 4, d_surfaces);
  }

  template< typename Element, size_t L, size_t T >
  void Field< Element, L, T >::setSurfaces()
  {
    size_t elSize = sizeof(Element) / sizeof(double);
    d_surfaces[idx_T] = MPI::DOUBLE.Create_vector(d_grid.localVolume() / d_grid.localVolume(),
                                                  d_grid.surface(idx_T) * elSize,
                                                  d_grid.localVolume() * elSize);
    d_surfaces[idx_T].Commit();

    d_surfaces[idx_X] = MPI::DOUBLE.Create_vector(d_grid.localVolume() / d_grid.surface(idx_T),
                                                  d_grid.surface(idx_X) * elSize,
                                                  d_grid.surface(idx_T) * elSize);
    d_surfaces[idx_X].Commit();

    d_surfaces[idx_Y] = MPI::DOUBLE.Create_vector(d_grid.localVolume() / d_grid.surface(idx_X),
                                                  d_grid.surface(idx_Y) * elSize,
                                                  d_grid.surface(idx_X) * elSize);
    d_surfaces[idx_Y].Commit();

    d_surfaces[idx_Z] = MPI::DOUBLE.Create_vector(d_grid.localVolume() / d_grid.surface(idx_Y),
                                                  d_grid.surface(idx_Z) * elSize,
                                                  d_grid.surface(idx_Y) * elSize);
    d_surfaces[idx_Z].Commit();
  }
}
