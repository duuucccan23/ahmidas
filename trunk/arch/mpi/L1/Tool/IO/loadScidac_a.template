template < typename Element >
int read_binary_gauge_data(LemonReader * reader, DML_Checksum * checksum)
{
  int t, x, y, z, status = 0;
  int latticeSize[] = {T_global, L, L, L};
  int scidacMapping[] = {0, 3, 2, 1};
  int prec;
  DML_SiteRank rank;
  MPI_Offset bytes;
  uint64_t fbsu3;
  char * filebuffer = NULL, * current = NULL;
  double tick = 0, tock = 0;
  char measure[64];

  bytes = lemonReaderBytes(reader);

  if (bytes == (n_uint64_t)g_nproc * (n_uint64_t)VOLUME * 4 * (n_uint64_t)sizeof(su3)) {
    prec = 64;
  }
  else {
    if (bytes == (n_uint64_t)g_nproc * (n_uint64_t)VOLUME * 4 * (n_uint64_t)sizeof(su3) / 2) {
      prec = 32;
    }
    else {
      fprintf(stderr, "Probably wrong lattice size or precision (bytes=%lu).\n", (unsigned long)bytes);
      return(-3);
    }
  }
  if (g_cart_id == 0 && g_debug_level > 2) {
    printf("# %d Bit precision read.\n", prec);
  }

  DML_checksum_init(checksum);

  fbsu3 = sizeof(su3);
  if (prec == 32) {
    fbsu3 /= 2;
  }
  bytes = 4 * fbsu3;

  if((void*)(filebuffer = malloc(VOLUME * bytes)) == NULL) {
    printf ("malloc errno in read_binary_gauge_data_parallel: %d\n", errno);
    errno = 0;
    /* do we need to abort here? */
    return(-1);
  }

  if (g_debug_level > 0)
  {
    MPI_Barrier(g_cart_grid);
    tick = MPI_Wtime();
  }
  lemonReadLatticeParallelMapped(reader, filebuffer, bytes, latticeSize, scidacMapping);

  if (g_debug_level > 0)
  {
    MPI_Barrier(g_cart_grid);
    tock = MPI_Wtime();

    if (g_cart_id == 0)
    {
      engineering(measure, L * L * L * T_global * bytes, "b");
      fprintf(stdout, "Time spent reading %s ", measure);
      engineering(measure, tock - tick, "s");
      fprintf(stdout, "was %s.\n", measure);
      engineering(measure, (L * L * L * T_global) * bytes / (tock - tick), "b/s");
      fprintf(stdout, "Reading speed: %s", measure);
      engineering(measure, (L * L * L * T_global) * bytes / (g_nproc * (tock - tick)), "b/s");
      fprintf(stdout, " (%s per MPI process).\n", measure);
      fflush(stdout);
    }
  }

  if (status < 0 && status != LEMON_EOR)
  {
    free(filebuffer);
    fprintf(stderr, "LEMON read error occured with status = %d while reading!\n", status);
    return(-2);
  }

  for (t = 0; t < T; t++) {
    for (z = 0; z < LZ; z++) {
      for (y = 0; y < LY; y++) {
        for (x = 0; x < LX; x++) {
          rank = (DML_SiteRank)(g_proc_coords[1] * LX +
                                (((g_proc_coords[0] * T + t) * g_nproc_z * LZ + g_proc_coords[3] * LZ + z) * g_nproc_y * LY
                                 + g_proc_coords[2] * LY + y) * ((DML_SiteRank)LX * g_nproc_x) + x);
          current = filebuffer + bytes * (x + (y + (t * LZ + z) * LY) * LX);
          DML_checksum_accum(checksum, rank, current, bytes);
          if (prec == 32) {
            be_to_cpu_assign_single2double(&g_gauge_field[ g_ipt[t][x][y][z] ][1], current            , sizeof(su3) / 8);
            be_to_cpu_assign_single2double(&g_gauge_field[ g_ipt[t][x][y][z] ][2], current +     fbsu3, sizeof(su3) / 8);
            be_to_cpu_assign_single2double(&g_gauge_field[ g_ipt[t][x][y][z] ][3], current + 2 * fbsu3, sizeof(su3) / 8);
            be_to_cpu_assign_single2double(&g_gauge_field[ g_ipt[t][x][y][z] ][0], current + 3 * fbsu3, sizeof(su3) / 8);
          }
          else {
            be_to_cpu_assign(&g_gauge_field[ g_ipt[t][x][y][z] ][1], current            , sizeof(su3) / 8);
            be_to_cpu_assign(&g_gauge_field[ g_ipt[t][x][y][z] ][2], current +     fbsu3, sizeof(su3) / 8);
            be_to_cpu_assign(&g_gauge_field[ g_ipt[t][x][y][z] ][3], current + 2 * fbsu3, sizeof(su3) / 8);
            be_to_cpu_assign(&g_gauge_field[ g_ipt[t][x][y][z] ][0], current + 3 * fbsu3, sizeof(su3) / 8);
          }
        }
      }
    }
  }
  DML_global_xor(&checksum->suma);
  DML_global_xor(&checksum->sumb);
  free(filebuffer);
  return(0);
}

template< typename Element >
void Tool::IO::loadScidac(Core::Field< Element > *field, std::string const &filename)
{
  // Clear whatever was hanging around in memory. Now we can just use raw for the buffer!
  field->reset();
  
  // Open the file for reading with MPI.
  MPI_File fp;
  MPI_File_open(field->grid(), filename.cstr(), MPI_MODE_RDONLY, MPI_INFO_NULL, &fp)
  
  // Initialize a reader with the file pointer.
  LemonReader *reader = lemonCreateReader(&fp, field->grid());

  // Declare trackers for searching file
  bool binaryReadFlag = false;
  
  // Look for the relevant records
  while ((status = ReaderNextRecord(reader)) != LIME_EOF)
  {
    if (status != LIME_SUCCESS)
    {
      std::cerr << "ReaderNextRecord returned status " << status << std::endl;
      break;
    }
    char *header_type = ReaderType(reader);
    if (strcmp("ildg-binary-data", header_type) == 0)
    {
      // We'll need an integer dimension pointer, hence the array
      lemonReadLatticeParallel(reader, field->raw(), (MPI_Offset)sizeof(Element), {field->L(), field->L(), field->L(), field->T()});
      binaryReadFlag = true;
      close_reader_record(reader);
      continue;
    }
    close_reader_record(reader);
  }
  
  // Deal with the results of the parsing
  if (!gauge_read_flag)
    std::cerr << "Did not find a binary record in " << filename << std::endl;

  lemonDestroyReader(reader);
}
