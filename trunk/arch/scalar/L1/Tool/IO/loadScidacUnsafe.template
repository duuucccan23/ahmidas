template< typename Element >
void Tool::IO::loadScidacUnsafe(Core::Field< Element > *field, std::string const &filename, size_t const precision)
{
  //Only use this function to load Scidac files which lack metadata describing precision and filesize.
  assert(precision == 32 || precision == 64);
  Lime::Reader reader(filename);

  if(!reader.good())
  {
    std::cerr << "Error occured trying to open file: " << filename << std::endl;
    exit(EXIT_FAILURE);
    return;
  }
  assert(reader.good());

  if (reader.findRecord("etmc-propagator-format") != reader.records())
  {
    std::cerr << "Unsafe function (Tool::IO::loadScidacUnsafe) used to read propagator: " << filename;
    std::cerr << "\nSafe method may have been possible (etmc-propagator-format Lime record found in file).\n";
  }

  reader.retrieveRecord(reader.findRecord("scidac-binary-data"));
  if (reader.fail())
  {
    std::cerr << "Lime reader could not find a scidac-binary-data record in file: " << filename << std::endl;
    exit(EXIT_FAILURE);
    return;
  }
  assert(reader.good());

  if (reader.recordSize() != field->volume() * sizeof(Element)/sizeof(double) * precision/8)
  {
    std::cerr << "scidac-binary-data record in file: " << filename << " does not match the given field and precision.\n";
    exit(EXIT_FAILURE);
    return;
  }

  Element *dataPtr = field->raw();

  if (precision == 64)
  {
    reader.read(dataPtr, field->volume());
    if (!Base::bigEndian)
      Base::swapEndian(dataPtr, dataPtr + field->volume(), sizeof(double));
    return;
  }

  size_t const elSize = sizeof(Element) / sizeof(double);
  uint32_t elem32[elSize];

  for (size_t ctr = 0; ctr < field->volume(); ++ctr, ++dataPtr)
  {
    reader.read(elem32, elSize);
    if (!Base::bigEndian)
      Base::swapEndian(elem32, elem32 + elSize);
    std::copy(reinterpret_cast< float* >(elem32), reinterpret_cast< float* >(elem32) + elSize,
              reinterpret_cast< double* >(dataPtr));
  }
}
