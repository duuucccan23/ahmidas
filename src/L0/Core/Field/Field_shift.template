namespace Core
{
  template< typename Element, size_t L, size_t T >
  Field< Element, L, T > &Field< Element, L, T >::shift(Base::SpaceTimeIndex idx, Base::Direction dir)
  {
    size_t dest = d_grid.neighbour(idx, dir);
    if (dest == d_grid.rank()) // We're just staying on the same node...
    {
      d_offsets[idx] += dir + d_grid.dim(idx);
      d_offsets[idx] %= d_grid.dim(idx); // Just move (and possibly wrap) the offset
      return *this;
    }

    int source = d_grid.neighbour(idx, dir == Base::dir_UP ? Base::dir_DOWN : Base::dir_UP);

    // We use a buffered send, so we should be safe from deadlocks
    void *v_buffer = d_buffer;
    MPI::Attach_buffer(v_buffer, d_bufferSize);

    d_grid.grid().Bsend(d_field + (d_offsets[idx] * d_grid.surface(idx)), 1, d_surfaces[idx], dest, TAG_GAUGEFIELD);
    d_grid.grid().Recv(d_field + (d_offsets[idx] * d_grid.surface(idx)), 1, d_surfaces[idx], source, TAG_GAUGEFIELD);

    // Detaching the buffer provides an implicit synchronization mechanism, since we now know the buffer is cleared.
    void *v_bufp = &v_buffer;
    MPI::Detach_buffer(v_bufp);

    // Now all we need to do is shift the offset to reflect the new situation
    d_offsets[idx] += dir + d_grid.dim(idx);
    d_offsets[idx] %= d_grid.dim(idx);

    return *this;
  }
}
