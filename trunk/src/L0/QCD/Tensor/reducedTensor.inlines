#include <iostream>
#include <iomanip>

namespace QCD
{

  inline std::complex< double > tr(reducedTensor const &rTensor)
  {
    return rTensor.trace();
  }

  inline std::complex< double > reducedTensor::trace() const
  {
    return d_data[0] + d_data[5] + d_data[10] + d_data[15];
  }

  inline size_t reducedTensor::size() const
  {
    return 16;
  }

  inline reducedTensor reducedTensor::elementwise_product(reducedTensor const &other) const
  {
    reducedTensor result;
    std::transform(d_data, d_data + 16, other.d_data, result.d_data, std::multiplies< std::complex< double > >());

    return result;
  }

  inline void reducedTensor::outer_product(reducedTensor const &other, reducedTensor* result) const
  {
    std::transform(d_data, d_data + 16, (*(result     )).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data     )));
    std::transform(d_data, d_data + 16, (*(result +  1)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  1)));
    std::transform(d_data, d_data + 16, (*(result +  2)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  2)));
    std::transform(d_data, d_data + 16, (*(result +  3)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  3)));
    std::transform(d_data, d_data + 16, (*(result +  4)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  4)));
    std::transform(d_data, d_data + 16, (*(result +  5)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  5)));
    std::transform(d_data, d_data + 16, (*(result +  6)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  6)));
    std::transform(d_data, d_data + 16, (*(result +  7)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  7)));
    std::transform(d_data, d_data + 16, (*(result +  8)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  8)));
    std::transform(d_data, d_data + 16, (*(result +  9)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  9)));
    std::transform(d_data, d_data + 16, (*(result + 10)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data + 10)));
    std::transform(d_data, d_data + 16, (*(result + 11)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data + 11)));
    std::transform(d_data, d_data + 16, (*(result + 12)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data + 12)));
    std::transform(d_data, d_data + 16, (*(result + 13)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data + 13)));
    std::transform(d_data, d_data + 16, (*(result + 14)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data + 14)));
    std::transform(d_data, d_data + 16, (*(result + 15)).d_data,
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data + 15)));
  }

  inline void reducedTensor::outer_product(reducedTensor const &other, std::complex< double >* result) const
  {
    std::transform(d_data, d_data + 16, (result     ),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data     )));
    std::transform(d_data, d_data + 16, (result +  1*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  1)));
    std::transform(d_data, d_data + 16, (result +  2*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  2)));
    std::transform(d_data, d_data + 16, (result +  3*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  3)));
    std::transform(d_data, d_data + 16, (result +  4*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  4)));
    std::transform(d_data, d_data + 16, (result +  5*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  5)));
    std::transform(d_data, d_data + 16, (result +  6*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  6)));
    std::transform(d_data, d_data + 16, (result +  7*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  7)));
    std::transform(d_data, d_data + 16, (result +  8*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  8)));
    std::transform(d_data, d_data + 16, (result +  9*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data +  9)));
    std::transform(d_data, d_data + 16, (result + 10*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data + 10)));
    std::transform(d_data, d_data + 16, (result + 11*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data + 11)));
    std::transform(d_data, d_data + 16, (result + 12*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data + 12)));
    std::transform(d_data, d_data + 16, (result + 13*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data + 13)));
    std::transform(d_data, d_data + 16, (result + 14*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data + 14)));
    std::transform(d_data, d_data + 16, (result + 15*16),
                   std::bind1st(std::multiplies< std::complex< double > >(), *(other.d_data + 15)));
  }

  inline void reducedTensor::eq_sandwich_operator(reducedTensor const &first, Base::Operator const op,
                                                  reducedTensor const &second)
  {
    std::copy(first.d_data, first.d_data + 16, d_data);
    switch (op)
    {
      case Base::op_GAMMA_4:
        Dirac::Gamma< 4 > gamma4;
        (*this) *= gamma4;
        (*this) *= second;
        break;
      default:
        std::cerr << "unknown Base::Operator field in "
                  << "void reducedTensor::eq_sandwich_operator(...)!"
                  << std::endl;
        std::cerr << "Aborting..." << std::endl;
        exit(1);
    }
  }

}
