namespace Core
{

  inline Correlator::Correlator(Correlator const &other)
    : L(other.L), T(other.T), d_weave(other.d_weave), d_data(other.d_data),
      d_sumTimeslice(other.d_sumTimeslice), d_sumTimeslice_global(other.d_sumTimeslice_global),
      d_references(other.d_references)
  {
    *d_references += 1;
  }


  inline Correlator::Correlator(size_t const L_, size_t const T_, Core::Field<Dirac::Matrix>* data)
    : L(L_), T(T_), d_weave(new Base::Weave(L_,T_)), d_data(data),
      d_sumTimeslice(new Dirac::Matrix[T_]), d_sumTimeslice_global(new Dirac::Matrix[T_]),
      d_references(new size_t(1))
  {
  }

  inline Correlator::~Correlator()
  {
    destroy();
  }


  inline Dirac::Matrix &Correlator::operator[](size_t const t)
  {
    assert(t < T);
    return d_sumTimeslice_global[t];
  }


  inline Dirac::Matrix const &Correlator::operator[](size_t const t) const
  {
    assert(t < T);
    return d_sumTimeslice_global[t];
  }


  inline void Correlator::operator*=(double const factor)
  {
    isolate();
    Core::Field< Dirac::Matrix >::iterator I = d_data->begin();
    while(I != d_data->end())
    {
      (*I) *= factor;
      ++I;
    }
  }

  inline void Correlator::operator*=(std::complex< double > const &factor)
  {
    isolate();
    Core::Field< Dirac::Matrix >::iterator I = d_data->begin();
    while(I != d_data->end())
    {
      (*I) *= factor;
      ++I;
    }
  }


  inline void Correlator::operator+=(Correlator const &other)
  {
    isolate();
    Core::Field< Dirac::Matrix >::iterator I = d_data->begin();
    Core::Field< Dirac::Matrix >::const_iterator J = other.d_data->begin();
    while(I != d_data->end())
    {
      (*I) += (*J);
      ++I;
      ++J;
    }
  }


  inline std::complex< double > Correlator::getTrSum(size_t const timeslice) const
  {
    assert(timeslice < T);
    return d_sumTimeslice_global[timeslice].trace();
  }

  inline size_t Correlator::getT() const
  {
    return T;
  }

  inline size_t Correlator::getL() const
  {
    return L;
  }

  inline size_t Correlator::size() const
  {
    return d_weave->localSize(Base::idx_T);
  }

  inline bool Correlator::isRoot() const
  {
    return d_weave->isRoot();
  }
  
  
  inline std::ostream &operator<<(std::ostream &out, Correlator const &c)
  {
    for (size_t t=0; t<c.getT(); t++)
    {
      // this is the way formatted output works in C++
      out.width(3);
      out << t << "  ";
      out.width(20);
      // since the Correlator stores complex numbers, we can access the real and imaginary parts using
      // the complex class member functions real() and imag()
      out << std::fixed << std::setprecision(10) << std::showpos << (c[t]).trace().real() << "  ";
      out.width(20);
      out << std::fixed << std::setprecision(10) << std::showpos << (c[t]).trace().imag() << std::endl;
    }
    return out;
  }
  

}
