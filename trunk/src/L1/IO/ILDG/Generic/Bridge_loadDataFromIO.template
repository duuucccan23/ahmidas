namespace IO
{ 
  template< typename Element, size_t L, size_t T >
  void Bridge< ILDG::Generic, Element, L, T >::loadDataFromIO()
  {
    size_t written = 0; //Number of locally written elements
    size_t const elementSize = sizeof(Element) / sizeof(double); // We assume Element is natively a collection of doubles
    size_t const precIO = d_io.precision() / 8;
  
    // We process all input as chars, to avoid any unpleasantness with floating point registers.
    if (d_field.d_grid.rank()) // Prepare to receive
    {
      char *fileBuffer = new char[elementSize * precIO * d_field.d_grid.contiguousBlock()];
      for (size_t ctr = 0; ctr < (d_field.d_grid.localVolume() / d_field.d_grid.contiguousBlock()); ++ctr)
      {
        d_field.d_grid.grid().Recv(fileBuffer, d_field.d_grid.contiguousBlock() * elementSize * precIO, 
                    MPI::BYTE, 0, Core::TAG_FILE_DISTRIBUTION);
        written = d_field.moveBufferToData(fileBuffer, written, precIO);
      }
      delete[] fileBuffer;
      return;
    }
  
    // At this point, we know we're node 0
    // Check the content of this file for a simple sanity condition -- is there enough data to begin with.
    size_t const *dims = d_io.dimensions();
    if (dims[Core::idx_X] != L || dims[Core::idx_Y] != L || 
        dims[Core::idx_Z] != L || dims[Core::idx_T] != T)
    {
      std::cerr << "[DEBUG] " << dims[Core::idx_X] << "  " << dims[Core::idx_Y]
                << "  " << dims[Core::idx_Z] << "  " << dims[Core::idx_T] << std::endl;
      std::cerr << "Content is of inappropriate size.\nAborting." << std::endl;
      MPI::COMM_WORLD.Abort(EIO);
    }
      
    char *fileBuffer = new char[elementSize * precIO * d_field.d_grid.contiguousBlock()];
  
    size_t nBlocks = d_field.d_grid.totalVolume() / d_field.d_grid.contiguousBlock();
    for (size_t ctr = 0; ctr < nBlocks; ++ctr)
    {
      d_io.read(fileBuffer, d_field.d_grid.contiguousBlock() * elementSize * precIO);
      if (d_io.fail())
      {
        std::cerr << "Unexpected error while performing I/O.\nAborting." << std::endl;
        MPI::COMM_WORLD.Abort(EIO);
      }
  
      size_t destination = d_field.d_grid.rank(ctr * d_field.d_grid.contiguousBlock());
      if (!destination) // This block of data should be stored locally
      {
        written = d_field.moveBufferToData(fileBuffer, written, precIO);
        continue;
      }
      d_field.d_grid.grid().Send(fileBuffer, d_field.d_grid.contiguousBlock() * elementSize * precIO, 
                  MPI::BYTE, destination, Core::TAG_FILE_DISTRIBUTION);
    }
    delete[] fileBuffer;
  }
}
